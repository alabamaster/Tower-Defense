/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <td>
#include <colorchat>

#define PLUGIN "TD: Vote Map"
#define VERSION "1.0"
#define AUTHOR "tomcionek15 & grs4"

#define MAPCYCLE_MAX_MAPS 33

new const g_szMapCycleFile[] = "mapcycle-towerdefense.txt";
new const g_szChatPrefix[]	= "[TD: Map Chooser]";

new bool:g_PluginOn;
new bool:g_PlayerVoted[33];
new bool:g_TimeToVote;

new g_szLastMapName[33]
new g_szMaps[MAPCYCLE_MAX_MAPS][33];
new g_iMapsVote[MAPCYCLE_MAX_MAPS]
new g_iMapsNum;
new g_iMaxPlayers;

new g_CvarTimeToVote;
new g_CvarWithRefresh;

public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	register_clcmd("say /vote", "cmdVoteMap");

	g_CvarTimeToVote = create_cvar("td_vote_time", "15", _, _, true, 1.0, false, _)
	g_CvarWithRefresh = create_cvar("td_vote_refresh_menu", "1", _, _, true, 0.0, true, 1.0)

	g_iMaxPlayers = get_maxplayers();
}

public plugin_cfg() {
	if(file_exists(g_szMapCycleFile))
		set_cvar_string("mapcyclefile", g_szMapCycleFile);
	else
		log_amx("TD: VoteMap | Mapcycle file '%s' does not exist!", g_szMapCycleFile);

	new szMapCycleFile[33];
	get_cvar_string("mapcyclefile", szMapCycleFile, 32);
		
	if(!file_exists(szMapCycleFile)) {
		g_PluginOn = false;
		
		return;
	}
	
	new szText[33], iLen;

	for(new i; read_file(szMapCycleFile, i, szText, 149, iLen) ; i++) {
		trim(szText);
		remove_quotes(szText);
		formatex(g_szMaps[i], 32, szText);
		g_iMapsNum ++;
	}
	
	/* Brak zapisanych map */
	if(!g_iMapsNum) {
		log_amx("TD: VoteMap | Mapcycle file '%s' is empty!", szMapCycleFile);
		g_PluginOn = false;
		return;
	}

	g_PluginOn = true;
}

public cmdVoteMap() {
	if(!g_PluginOn)
		return;
	
	g_TimeToVote = true;
	
	ColorChat(0, GREEN, "^x04%s^x01 Voting is started! Time remaing %d second!", g_szChatPrefix, get_pcvar_num(g_CvarTimeToVote));
	set_task(float(get_pcvar_num(g_CvarTimeToVote)), "cmdVoteMapEnd");

	for(new i = 1; i < g_iMaxPlayers ; i++)
		if(is_user_connected(i))
			showMenu(i,0)
}

public showMenu(id,page) {
	new szTitle[64];
	new szItem[64];
	
	formatex(szTitle, charsmax(szTitle), "\yChoose next map: ");
	
	new iMenu  = menu_create(szTitle, "cmdVoteMap_Handler");
	new iCb = menu_makecallback("cmdVoteMap_Callback");

	for(new i ; i < g_iMapsNum ; i++) {
		if(equali(g_szLastMapName, g_szMaps[i]))
			continue;
		
		formatex(szItem, charsmax(szItem), "\w%s \y[ \w%d votes \y]", g_szMaps[i], g_iMapsVote[i])
		
		new iIndex[4];
		num_to_str(i, iIndex, 3);
		
		menu_additem(iMenu, szItem, iIndex, _, iCb);
	}
	
	menu_display(id, iMenu, page, get_pcvar_num(g_CvarTimeToVote))
}
public cmdVoteMap_Callback(id, menu, item) {
	if(g_PlayerVoted[id])
		return ITEM_DISABLED;

	return ITEM_ENABLED;
}

public cmdVoteMap_Handler(id, menu, item) {
	if(!is_user_connected(id) || !g_TimeToVote)
		return;
	
	if(item == MENU_EXIT && !g_PlayerVoted[id]) {
		menu_display(id, menu);

		ColorChat(id, GREEN, "^x04%s^x01 You have to vote!", g_szChatPrefix);
		//ColorChat(0, GREEN, "^x04%s^x01 Player^x04 %s^x01 decided to not participate to the vote.", g_szChatPrefix, szNick);
		
		return;
	}
	else if (item == MENU_EXIT && g_PlayerVoted[id]) {
		if(menu)
			menu_destroy(menu)
		return
	}
	new szData[6], iName[4];
	new access, callback;
    	new szNick[33];
	get_user_name(id, szNick, 32);

	menu_item_getinfo(menu, item, access, szData, 5, iName, 3, callback);
    	new iIndex = str_to_num(szData);

	g_PlayerVoted[id] = true;
	g_iMapsVote[iIndex] ++;

	ColorChat(0, GREEN, "^x04%s^x01 Player^x04 %s^x01 voted for^x04 %s.", g_szChatPrefix, szNick, g_szMaps[iIndex])
	
	static bool:iRefresh;
	if(!iRefresh) 
		iRefresh = bool:get_pcvar_num(g_CvarWithRefresh)
	
	if(iRefresh)
		cmdRefreshMenu(menu);
}

public cmdRefreshMenu(iMenu) {
	if(!g_TimeToVote)
		return
		
	for(new i = 1; i < g_iMaxPlayers ; i++) {
		if(is_user_connected(i)) {
			menu_cancel(i)
			if(!g_PlayerVoted[i]) {
				new page,m,m2
				player_menu_info(i, m, m2, page)
				if(m2) {
					showMenu(i, page)	
					continue
				}
			}
			
			showMenu(i, 0)
		}
	}
}

public cmdVoteMapEnd() {
	ColorChat(0, GREEN, "^x04%s^x01 Voting for next map has just ends!", g_szChatPrefix)
	g_TimeToVote = false
	new iTemp = 0, id=0
	for(new i ; i < MAPCYCLE_MAX_MAPS ; i++) {
		if(g_iMapsVote[i] > iTemp) {
			id = i
			iTemp = g_iMapsVote[id]
		}
	}
	new ids[9]
	ids[0] = id
	new iTemp2  = 1// tu nizej szuka drugiej co ma tyle samo
	for(new i ; i < MAPCYCLE_MAX_MAPS ; i++) {
		if(g_iMapsVote[i] == iTemp && i != id) {
			ids[iTemp2++] = i
		}
	}
	
	// jesli sa dwie mapy co maja tyle samo glosow
	if(iTemp2 > 1) {
		iTemp = ids[random(iTemp2-1)]
		ColorChat(0, GREEN, "^x04%s^x01 Between^x04 %d^x01 maps [^x04 %d votes ^x01] will be drawn one map!", g_szChatPrefix, iTemp2, g_iMapsVote[iTemp])
		set_task(3.0, "printEndChat", iTemp)
		return
		
	}
	iTemp = id
	printEndChat(iTemp)
	
}

public printEndChat(iTemp) {
	ColorChat(0, GREEN, "^x04%s^x01 Next map will be ^x04%s^x01 with^x04 %d^x01 votes!", g_szChatPrefix, g_szMaps[iTemp], g_iMapsVote[iTemp])
	set_cvar_string("amx_nextmap", g_szMaps[iTemp]);
}