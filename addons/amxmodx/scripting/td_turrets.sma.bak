/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta_util>
#include <hamsandwich>
#include <xs>
#include <td>
#include <colorchat>
#include <fun>

#pragma dynamic 32768 

#define PLUGIN "TD Turrets: New"
#define VERSION "0.5"
#define AUTHOR "GT Team"

#define MAX_PLAYER_TURRET 3
#define MAX_SERVER_TURRET 20
#define MAX_TURRETS_LEVEL 50

#define EV_INT_turret_id 		EV_INT_iuser1
#define EV_INT_turret_type 	EV_INT_iuser2
#define EV_INT_turret_firemode 	EV_INT_iuser3
#define EV_INT_turret_target	EV_INT_iuser4
#define EV_ENT_turret_owner 	EV_ENT_owner
#define EV_ENT_turret_ammobar	EV_ENT_euser2
#define EV_ENT_turret_ranger	EV_ENT_euser3

#define EV_INT_ranger_status	EV_INT_iuser1

new g_szTurretsDefaultConfigFile[] = "td_turrets_default.cfg"
new g_szTurretsConfigDir[]	= "addons/amxmodx/configs/Tower Defense/Turrets/"

new g_szSoundConfigFile[] 	= "addons/amxmodx/configs/td_sounds.cfg";
new g_szLogFile[] 		= "Tower Defense.log"
new g_szPrefix[16]
new g_szLangFile[] 		= "TowerDefense.txt"

new MAX_MAP_TURRET

enum e_Sound {
	SOUND_TURRET_NORMAL_FIRE_1,
	SOUND_TURRET_NORMAL_FIRE_2,
	SOUND_TURRET_LASER_FIRE_1,
	SOUND_TURRET_LASER_FIRE_2,
	SOUND_TURRET_LIGHTING_FIRE_1,
	SOUND_TURRET_LIGHTING_FIRE_2,
	SOUND_TURRET_START_FIRE,
	SOUND_TURRET_STOP_FIRE,
	SOUND_TURRET_PLANT,
	SOUND_TURRET_LOWAMMO,
	SOUND_TURRET_NOAMMO,
	SOUND_MENU_SELECT
}

enum e_Cvar {
	CVAR_TURRET_NORMAL_AMMO,
	CVAR_TURRET_LASER_AMMO,
	CVAR_TURRET_LIGHTING_AMMO,
	CVAR_TURRET_NORMAL_AMMO_NUM,
	CVAR_TURRET_LASER_AMMO_NUM,
	CVAR_TURRET_LIGHTING_AMMO_NUM,
	CVAR_TURRET_MOVE_COST,
	CVAR_TURRET_SHOW_AMMO_BAR,
	CVAR_TURRET_MOVE_ACTIVATION,
	CVAR_TURRET_RELOAD_TIME,
	CVAR_TURRET_INSTALL_TIME,
	CVAR_TURRET_UPGRADE_TIME,
	CVAR_TURRET_CHANGE_ENEMY_TIME,
	CVAR_TURRET_SHOW_AMMO
}
enum e_CvarValue {
	TURRET_NORMAL_AMMO,
	TURRET_LASER_AMMO,
	TURRET_LIGHTING_AMMO,
	TURRET_NORMAL_AMMO_NUM,
	TURRET_LASER_AMMO_NUM,
	TURRET_LIGHTING_AMMO_NUM,
	TURRET_MOVE_COST,
	TURRET_SHOW_AMMO_BAR,
	Float:TURRET_MOVE_ACTIVATION,
	Float:TURRET_RELOAD_TIME,
	Float:TURRET_INSTALL_TIME,
	Float:TURRET_UPGRADE_TIME,
	Float:TURRET_CHANGE_ENEMY_TIME,
	TURRET_SHOW_AMMO
}
enum {
	TASK_UPGRADE_TURRET = 1451,
	TASK_CREATE_TURRET_INFO = 1520,
	TASK_RELOAD_AMMO = 1643,
	TASK_MOVE_TURRET = 1796
}

new const g_szTurretsName[e_TurretsType][] = {
	"BRAK",
	"NABOJE",
	"LASER",
	"PIORUN"
}

new const g_szTurretsShopName[MAX_PLAYER_TURRET][] = {
	"Sentry 1",
	"Sentry 2",
	"Sentry 3"
}

new const g_iSlotCost[MAX_PLAYER_TURRET] = {
	10,
	25,
	30
}

new g_CvarChatPrefix;

new g_iServerTurretsNum
new g_TurretsFreqData[e_TurretsType]
new g_TurretsPriceData[e_TurretsType][MAX_TURRETS_LEVEL]
new g_TurretsDamageData[e_TurretsType][MAX_TURRETS_LEVEL][2]
new g_TurretsRangeData[e_TurretsType][MAX_TURRETS_LEVEL]
new g_TurretsMaxLevelData[e_TurretsType][2] // 0 - damage | 1 - range

new g_CvarInfo[e_Cvar]
new g_CvarValue[e_CvarValue]

new g_Sounds[e_Sound][128]

new e_TurretsType:g_PlayerTurretType[33][MAX_PLAYER_TURRET]

new bool:g_PlayerSlot[33][MAX_PLAYER_TURRET]
new bool:g_PlayerAlarmStatus[33][MAX_PLAYER_TURRET]
new bool:g_PlayerTurretIsUpgrading[33][MAX_PLAYER_TURRET];

new g_PlayerTurretEnt[33][MAX_PLAYER_TURRET]
new g_PlayerTurretLevel[33][MAX_PLAYER_TURRET]
new g_PlayerTurretDamageLevel[33][MAX_PLAYER_TURRET]
new g_PlayerTurretRangeLevel[33][MAX_PLAYER_TURRET]
new g_PlayerTurretAmmo[33][MAX_PLAYER_TURRET]
new g_PlayerTurretMove[33]
new g_PlayerTurretNum[33]; 

new Float:g_fPlayerHudGameTime[33];
new Float:g_fPlayerAmmoBarScale[33];
new Float:g_fPlayerExtraTime[33];

new g_iPlayerAlarmValue[33];

new g_SpriteLaserBeam;
new g_SpriteRanger[] = "sprites/TD/ranger.spr"
new g_SpriteAmmoBar[] = "sprites/TD/turrets.spr"
new g_ShellIndex

new g_HudMessage;

new g_ForwardLowAmmo
new g_ForwardNoAmmo

public plugin_precache()  {
	LoadSound()
	for(new i; i < _:e_Sound ; i++) {
		precache_sound(g_Sounds[e_Sound:i]);
	}
	precache_model("models/TD/sentrygun_1.mdl")
	precache_model("models/TD/sentrygun_2.mdl")
	precache_model("models/TD/sentrygun_3.mdl")
	precache_model("models/TD/sentrygun_4.mdl")
	precache_model("models/TD/sentrygun_5.mdl")
	
	g_ShellIndex 		= precache_model("models/rshell_big.mdl")
	g_SpriteLaserBeam 	= precache_model("sprites/TD/laserbeam.spr")
	
	precache_model(g_SpriteRanger)
	precache_model(g_SpriteAmmoBar)
}

public plugin_natives() {
	register_native("td_set_ammobar_scale", 		"ChangeAmmoBarScale", 1);
	register_native("td_set_alarm_value", 		"ChangeAlarmValue", 1);
	register_native("td_get_player_alarm_value", 	"_get_alarm_value", 1)
	register_native("td_get_player_turret_type", 	"_get_player_turret_type", 1);
	register_native("td_set_player_turret_type", 	"_set_player_turret_type", 1);
	register_native("td_get_player_turret_slot", 	"_get_player_turret_slot", 1);
	register_native("td_set_player_turret_slot", 	"_set_player_turret_slot", 1);
	register_native("td_turret_is_upgrading", 		"_turret_is_upgrading", 1);
	register_native("td_get_turret_entity", 		"_get_turret_entity", 1);
	register_native("td_get_turret_level", 		"_get_turret_level", 1);
	register_native("td_get_turret_damage_level", 	"_get_turret_damage_level", 1);
	register_native("td_get_turret_range_level", 	"_get_turret_range_level", 1);
	register_native("td_get_turret_ammo", 		"_get_turret_ammo", 1);
	register_native("td_set_turret_ammo", 		"_set_turret_ammo", 1);
	register_native("td_player_is_moving_turret", 	"_is_moving_turret", 1);
	register_native("td_get_moved_turret_entity", 	"_get_moved_turret_entity", 1);
	register_native("td_get_player_turrets_num", 	"_get_turrets_num", 1);
	register_native("td_get_turret_target", 		"_get_turret_target", 1);
	register_native("td_get_turret_ammobar", 		"_td_get_turret_ammobar", 1);
	register_native("td_get_turret_owner", 		"_get_turret_owner", 1);
	register_native("td_get_turret_ranger", 		"_get_turret_ranger", 1);
	register_native("td_set_alarm_value", 		"ChangeAlarmValue", 1);
	register_native("td_get_turret_ranger_status", 	"_get_turret_ranger_status", 1);
	register_native("td_get_turret_id", 			"_get_turret_id", 1);
	register_native("td_is_turret", 			"_td_is_turret", 1);
	register_native("td_is_ranger", 			"_td_is_ranger", 1);
	register_native("td_is_ammobar", 			"_td_is_ammobar", 1);
	register_native("td_is_turret_on_server", 		"_td_is_turret_on_server", 1);
	register_native("td_is_ranger_exists",		"_td_is_ranger_exists", 1);
	register_native("td_get_max_turrets_per_player","get_max_turrets_per_player", 1);
	register_native("td_get_max_server_turrets", 	"get_max_server_turrets", 1);
	register_native("td_get_turret_alarm_status", 	"_get_turret_alarm_status", 1)
	register_native("td_show_turrets_menu", 		"cmdmenuTurrets", 1);

	register_native("td_get_player_extra_time", 	"_td_get_player_extra_time", 1);
	register_native("td_set_player_extra_time", 	"_td_set_player_extra_time", 1);
}

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)

	register_dictionary(g_szLangFile);
	
	if(td_get_game_status() == GAME_NOT_AVAILABLE) {
		log_amx("[GAME_NOT_AVAILABLE] There was a problem in engine | td_new.amxx")
		log_amx("[GAME_NOT_AVAILABLE] Work of this plugin was stopped")
	}
	else {
		register_forward(FM_AddToFullPack, "fwAddToFullPack", 0)
		
		register_think("turret", 		"TurretThink")
		register_clcmd("say /turrets", 	"cmdmenuTurrets");
		register_clcmd("say /turret", 	"cmdmenuTurrets");
		register_clcmd("say /turret", 	"cmdmenuTurrets");

		g_HudMessage = CreateHudSyncObj();
		
		LoadCvars()
		
		new szMapName[33]
		get_mapname(szMapName, 32)
		LoadTurretsConfig(szMapName)
	}
	
	g_ForwardLowAmmo 	= CreateMultiForward("td_turret_low_ammo", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL)
	g_ForwardNoAmmo 	= CreateMultiForward("td_turret_no_ammo", ET_CONTINUE, FP_CELL, FP_CELL, FP_CELL)
}

public LoadCvars() {
	/* Cvary */
	
	g_CvarInfo[CVAR_TURRET_NORMAL_AMMO] 		= create_cvar("td_turret_normal_ammo_cost",	 "15", _, _, true, 0.0, false, _)
	g_CvarInfo[CVAR_TURRET_LASER_AMMO] 		= create_cvar("td_turret_laser_ammo_cost", 	"20", _, _, true, 0.0, false, _)
	g_CvarInfo[CVAR_TURRET_LIGHTING_AMMO] 	= create_cvar("td_turret_lighting_ammo_cost", 	"25", _, _, true, 0.0, false, _)
	
	g_CvarInfo[CVAR_TURRET_NORMAL_AMMO_NUM]	= create_cvar("td_turret_normal_ammo_num", 	"250", _, _, true, 0.0, false, _)
	g_CvarInfo[CVAR_TURRET_LASER_AMMO_NUM]	= create_cvar("td_turret_laser_ammo_num",	 "100", _, _, true, 0.0, false, _)
	g_CvarInfo[CVAR_TURRET_LIGHTING_AMMO_NUM]	= create_cvar("td_turret_lighting_ammo_num", 	"400", _, _, true, 0.0, false, _)
	
	g_CvarInfo[CVAR_TURRET_MOVE_COST]  		= create_cvar("td_turret_move_cost", 		"10", _, _, true, 0.0, false, _)
	g_CvarInfo[CVAR_TURRET_MOVE_ACTIVATION] 	= create_cvar("td_turret_move_activation", 	"3.0", _, _, true, 0.1, false, _)
	
	g_CvarInfo[CVAR_TURRET_SHOW_AMMO_BAR] 	= create_cvar("td_turret_show_ammo_bar", 	"1", _, _, true, 0.0, true,2.0) // 0 - wylaczone ; 1 - tylko wlasciciel ; 2 - wszyscy
	
	g_CvarInfo[CVAR_TURRET_RELOAD_TIME] 		= create_cvar("td_turret_reload_time", 		"3.0", _, _, true, 0.1, false, _)
	g_CvarInfo[CVAR_TURRET_INSTALL_TIME]		= create_cvar("td_turret_install_time", 		"1.5", _, _, true, 0.1, false, _)
	g_CvarInfo[CVAR_TURRET_UPGRADE_TIME] 		= create_cvar("td_turret_upgrade_time", 		"2.0", _, _, true, 0.1, false, _)
	
	g_CvarInfo[CVAR_TURRET_SHOW_AMMO] 		= create_cvar("td_turret_show_ammo", 		"2", _, _, true, 0.0, true, 2.0) // 0 - nie | 1 - tylko twoich wie?yczek | 2 - wszystkic wie?yczek
	
	g_CvarInfo[CVAR_TURRET_CHANGE_ENEMY_TIME]	= create_cvar("td_turret_change_enemy_time", "	0.35", _, _, true, 0.01, false, _)
	
	g_CvarChatPrefix					= create_cvar("td_turret_chat_prefix", "[TD:TURRETS]", _, _, _, _, _, _)
	
	for(new i; i < _:e_Cvar;i++) {
		if(e_Cvar:i == CVAR_TURRET_MOVE_ACTIVATION || e_Cvar:i == CVAR_TURRET_RELOAD_TIME || e_Cvar:i == CVAR_TURRET_INSTALL_TIME || e_Cvar:i ==  CVAR_TURRET_UPGRADE_TIME || e_Cvar:i ==  CVAR_TURRET_CHANGE_ENEMY_TIME) 
			bind_pcvar_float(g_CvarInfo[e_Cvar:i], Float:g_CvarValue[e_CvarValue:i])
		else
			bind_pcvar_num(g_CvarInfo[e_Cvar:i], g_CvarValue[e_CvarValue:i])
	}

	bind_pcvar_string(g_CvarChatPrefix, g_szPrefix, charsmax(g_szPrefix))
}

public client_disconnect(id) {
	td_reset_player_info(id)
}

public client_connect(id) {
	td_reset_player_info(id)
}
public td_reset_player_info(id) {
	for(new i; i < MAX_PLAYER_TURRET; i++) {
		DeleteTurret(id, g_PlayerTurretEnt[id][i])
		g_PlayerSlot[id][i] = false
	}
	
	g_PlayerTurretMove[id] = 0
	g_fPlayerHudGameTime[id] = 0.0
	g_fPlayerAmmoBarScale[id] = 0.3
	g_iPlayerAlarmValue[id] = 50
	g_fPlayerExtraTime[id] = 0.0
}

public td_reset_game(iMode, Float:fTime) 
	ColorChat(0, GREEN, "%s^x01 Game was resets! All turrets were be removed!", g_szPrefix)

public fwAddToFullPack(es_handle, e, ENT, HOST, hostflags, player, set) {
	if(player || !is_user_connected(HOST) || !is_user_alive(HOST) || !is_valid_ent(ENT)) 
		return FMRES_IGNORED;

	if(_td_is_ranger(ENT) && entity_get_int(ENT, EV_INT_ranger_status)) {
		set_es(es_handle, ES_RenderMode, kRenderTransAdd)
               // set_es(es_handle, ES_RenderFx, kRenderFxNone)
		if(entity_get_edict(ENT, EV_ENT_turret_owner) == HOST)
			 return FMRES_IGNORED;
		else {
		         set_es(es_handle, ES_RenderAmt, 0)
		         return FMRES_OVERRIDE
                }
		
	}
	else if(td_is_ammobar(ENT)) {
		for(new i ; i < MAX_PLAYER_TURRET ; i++) {
			if(is_valid_ent( entity_get_edict(g_PlayerTurretEnt[HOST][i], EV_ENT_turret_ammobar)))
				entity_set_float( entity_get_edict(g_PlayerTurretEnt[HOST][i], EV_ENT_turret_ammobar), EV_FL_scale, g_fPlayerAmmoBarScale[HOST])
		}
		
		if(g_CvarValue[TURRET_SHOW_AMMO_BAR] == 1) {
		        set_es(es_handle, ES_RenderMode, kRenderTransTexture)
     			//es(es_handle, ES_RenderFx, kRenderFxNone)
			
			if(entity_get_edict(ENT, EV_ENT_turret_owner) == HOST)
				return FMRES_IGNORED
			else {
			        set_es(es_handle, ES_RenderAmt, 0)
			        return FMRES_OVERRIDE
		        }

		}
	}	

	return FMRES_IGNORED			
}

public getClosestTurret(index, Float:radius, mode) {
	new iEntList[6]
	new iNum = find_sphere_class(index, "turret", radius, iEntList, 5)
	
	return iNum ? iEntList[mode] : 0
}

public client_PostThink(id) {
	if(is_user_alive(id)) {
		if(get_gametime() > g_fPlayerHudGameTime[id] + 1.0 && !g_PlayerTurretMove[id]) {
			if(_td_is_turret_on_server()) {
				new iEnt = getClosestTurret(id, 60.0, 0)
				
				if(iEnt) {
					new szText[150];
					new szTemp[33];
					new iOwner = entity_get_edict(iEnt, EV_ENT_turret_owner) 
					get_user_name(iOwner, szTemp, charsmax(szTemp))
					
					formatex(szText, charsmax(szText), "%L^n%L", id, "TURRET_INFO_1", g_szTurretsName[e_TurretsType:entity_get_int(iEnt, EV_INT_turret_type)], id, "TURRET_INFO_2", szTemp)
					formatex(szTemp, charsmax(szTemp), "")

					if(iOwner  == id  && g_CvarValue[TURRET_SHOW_AMMO] == 1)
						formatex(szTemp, charsmax(szTemp), "^n%L",  id, "TURRET_INFO_3", g_PlayerTurretAmmo[id][entity_get_int(iEnt, EV_INT_turret_id)])
					else if(g_CvarValue[TURRET_SHOW_AMMO] == 2) 
						formatex(szTemp, charsmax(szTemp), "^n%L",  id, "TURRET_INFO_3", g_PlayerTurretAmmo[iOwner][entity_get_int(iEnt, EV_INT_turret_id)])
		
					if(g_CvarValue[TURRET_SHOW_AMMO] != 0)
						add(szText, charsmax(szText), szTemp)
				
					set_hudmessage(212, 255, 255, -1.0, 0.75, 0, 6.0, 1.1)
					if(iOwner == id) {
						formatex(szTemp, charsmax(szTemp), "^n%L", id, "TURRET_INFO_4")
						add(szText, charsmax(szText), szTemp)
						if(get_user_button(id) & IN_USE)
							menuTurret(id, entity_get_int(iEnt, EV_INT_turret_id))
					}
					ShowSyncHudMsg(id, g_HudMessage, szText);
						
				}
				
				g_fPlayerHudGameTime[id] = get_gametime();
			}
		}
		if(is_valid_ent(g_PlayerTurretMove[id])) {
			static Float:fOrigin[3]
			
			get_origin_from_dist_player(id, 70.0, fOrigin)
			entity_set_model(g_PlayerTurretMove[id], "models/TD/sentrygun_2.mdl")
			entity_set_origin(g_PlayerTurretMove[id], fOrigin)
			drop_to_floor(g_PlayerTurretMove[id])
			
			entity_get_vector(g_PlayerTurretMove[id], EV_VEC_origin, fOrigin)
			static Origin[3], Float:fTempOrigin[3]
			get_user_origin(id, Origin, 3)
			IVecFVec(Origin, fTempOrigin)
			
			TurretTurnToTarget(g_PlayerTurretMove[id], 0, 1, fTempOrigin);
			
			new entlist[3]
			
			new iEnt = getClosestTurret(g_PlayerTurretMove[id], 60.0, 1);
			
			if(is_valid_ent(iEnt)) 
				entity_set_model(g_PlayerTurretMove[id], "models/TD/sentrygun_4.mdl")
			else if(find_sphere_class(g_PlayerTurretMove[id], "func_illusionary", 10.0, entlist, 2))
				entity_set_model(g_PlayerTurretMove[id], "models/TD/sentrygun_4.mdl")
			else if(!fm_is_ent_visible(id, g_PlayerTurretMove[id]))
				entity_set_model(g_PlayerTurretMove[id], "models/TD/sentrygun_4.mdl")
			
			/* Ranger */
			
			fOrigin[2] += 1.0
		
			entity_set_origin(entity_get_edict(g_PlayerTurretMove[id], EV_ENT_turret_ranger), fOrigin)
			
			/* ----- */
		}
			
	}
	
}

public cmdmenuTurrets(id) {
	if(!is_user_connected(id)  || !is_user_alive(id))
		return PLUGIN_CONTINUE;
	
	new szFormat[128], szAlarm[33];
	
	formatex(szAlarm, 32, "%L", id, "MENU_TURRET_TITLE")
	new menu = menu_create(szAlarm, "cmdmenuTurretsH")
	new cb = menu_makecallback("cmdmenuTurretsCb");
	
	new iGold = td_get_user_info(id, PLAYER_GOLD)
	
	for(new i ; i < MAX_PLAYER_TURRET; i++) {
		TurretRangerTurnOff(g_PlayerTurretEnt[id][i])
		if(g_iServerTurretsNum >= MAX_SERVER_TURRET && !is_valid_ent(g_PlayerTurretEnt[id][i]))
			formatex(szFormat, charsmax(szFormat), "%L \r %L", id, "MENU_TURRET_SLOT", i+1, id, "MENU_TURRET_SERVER_LIMIT")
		else if(g_iServerTurretsNum >= MAX_MAP_TURRET && !is_valid_ent(g_PlayerTurretEnt[id][i]))
			formatex(szFormat, charsmax(szFormat), "%L \r %L",id, "MENU_TURRET_SLOT", i+1, id, "MENU_TURRET_MAP_LIMIT")
		else if(g_PlayerSlot[id][i] == false && iGold < g_iSlotCost[i])
			formatex(szFormat, charsmax(szFormat), "%L \r %L", id, "MENU_TURRET_SLOT",i+1, id, "MENU_TURRET_SLOT_COST", g_iSlotCost[i])
		else if(g_PlayerSlot[id][i] == false && iGold >= g_iSlotCost[i])
			formatex(szFormat, charsmax(szFormat), "%L \r %L",id, "MENU_TURRET_SLOT", i+1,id , "MENU_TURRET_SLOT_BUY",  g_iSlotCost[i])
		/* Je?li kupi3 slot */
		
		else if(g_PlayerSlot[id][i] == true) {
			/* Je?li nie ma kupionej wie?yczki */
			
			if(!is_valid_ent(g_PlayerTurretEnt[id][i]))
				formatex(szFormat, charsmax(szFormat), "%L \r%L", id, "MENU_TURRET_SLOT", i+1, id, "MENU_TURRET_BUY_TURRET")
			else
				formatex(szFormat, charsmax(szFormat), "%s \r[ \y%d lvl\r ] [ \y%s\r ]", g_szTurretsShopName[i], g_PlayerTurretLevel[id][i], g_szTurretsName[g_PlayerTurretType[id][i]])
		}
		
		if(g_PlayerAlarmStatus[id][i] == true) {
			formatex(szAlarm,32, "%L", id, "MENU_TURRET_LOW_AMMO")
			
			if(g_PlayerTurretAmmo[id][i] == -1)
				formatex(szAlarm, 32, "%L", id, "MENU_TURRET_NO_AMMO")
			add(szFormat, 127, szAlarm)
		}
		
		menu_additem(menu, szFormat, _, _, cb)
	}
	
	formatex(szAlarm,32, "%L", id, "BACK")
	menu_setprop(menu, MPROP_EXITNAME, szAlarm);
	menu_display(id, menu)
	
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);	
	
	return PLUGIN_CONTINUE
}

public cmdmenuTurretsCb(id, menu, item) { 
	new iGold = td_get_user_info(id, PLAYER_GOLD)
	new IS;
	if(IS)
		return ITEM_DISABLED
		
	for(new i ; i < MAX_PLAYER_TURRET; i++) {	
		if(g_PlayerTurretIsUpgrading[id][i]) {
			IS = 1
			return ITEM_DISABLED
		}
		else if((g_iServerTurretsNum >= MAX_SERVER_TURRET  || g_iServerTurretsNum >= MAX_MAP_TURRET) && g_PlayerTurretEnt[id][i] <= 0 && item == i)
			return ITEM_DISABLED
		else if(g_PlayerSlot[id][i] == false && iGold < g_iSlotCost[i] && item == i)
			return ITEM_DISABLED
	}
	
	return ITEM_ENABLED
}

public cmdmenuTurretsH(id, menu, item) {
	if(item == MENU_EXIT || !is_user_alive(id)) {
		menu_destroy(menu)
		return PLUGIN_CONTINUE
	}
	
	if(!g_PlayerSlot[id][item]) {
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-g_iSlotCost[item])
		
		ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix, id, "CMD_BUY_SLOT_INFO", item+1)
		
		g_PlayerSlot[id][item] = true
		
		cmdmenuTurrets(id);
		return PLUGIN_CONTINUE 
	}
	else if(g_PlayerSlot[id][item] && !is_valid_ent(g_PlayerTurretEnt[id][item])) {
		menuBuyTurret(id, item)
	}
	else if(g_PlayerSlot[id][item] && is_valid_ent(g_PlayerTurretEnt[id][item])) {
		menuTurret(id, item)
	}
	
		
	return PLUGIN_CONTINUE;
}

public menuBuyTurret(id, sentryid) {
	TurretRangerTurnOff(g_PlayerTurretMove[id])
	
	if(is_valid_ent(g_PlayerTurretMove[id]))
		remove_entity(g_PlayerTurretMove[id])
	
	g_PlayerTurretMove[id] = 0
	
	new szFormat[64];
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_T_BUY_TITLE")
	
	new iMenu  = menu_create(szFormat, "menuBuyTurretH")
	new cb = menu_makecallback("menuBuyTurretCb")
	
	new szData[4]
	num_to_str(sentryid, szData, 3)
	
	for(new i = 1; i < _:e_TurretsType; i++) {
		formatex(szFormat, charsmax(szFormat), "%s \r%L", g_szTurretsName[e_TurretsType:i], id, "MENU_T_BUY_COST", g_TurretsPriceData[e_TurretsType:i][0])
		menu_additem(iMenu, szFormat, szData, _, cb)
	}
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "BACK");
	menu_setprop(iMenu, MPROP_EXITNAME, szFormat)
	menu_display(id, iMenu)
}

public menuBuyTurretCb(id, menu, item)
{
	for(new i = 1; i < _:e_TurretsType; i++)
		if(td_get_user_info(id, PLAYER_GOLD) < g_TurretsPriceData[e_TurretsType:i][0] && item == i-1)
			return ITEM_DISABLED
	return ITEM_ENABLED
}

public menuBuyTurretH(id, menu, item)
{
	if(item == MENU_EXIT || !is_user_alive(id)) {
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	
	new acces, szSentryId[4], name[3], cb
	menu_item_getinfo(menu, 0, acces, szSentryId, 3, name, 2, cb)
	
	new szFormat[64]
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_T_H_TITLE")
	
	new iMenu = menu_create(szFormat, "menuBuyTurret2H")
	
	new szType[4]
	num_to_str(item+1, szType, 3)
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_T_H_PLACE_THERE")
	menu_additem(iMenu, szFormat, szSentryId)
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "BACK")
	menu_additem(iMenu, szFormat, szType)
	
	menu_display(id, iMenu)
	
	if(!g_PlayerTurretMove[id])
		CreateMoveEffectTurret(id, e_TurretsType:(item+1), 0)
		
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	return PLUGIN_CONTINUE
}

public menuBuyTurret2H(id, menu, item)
{
	new acces, szSentryId[4], szType[4], cb
	
	menu_item_getinfo(menu, 0, acces, szSentryId, 3, szType, 3, cb)
	new turret = str_to_num(szSentryId)
	
	menu_item_getinfo(menu,1, acces, szType, 3, szSentryId, 3, cb)
	new Type = str_to_num(szType)
	
	if(item == MENU_EXIT || !is_user_alive(id) || item == 1) {
		menu_destroy(menu)
		menuBuyTurret(id, turret)
		return PLUGIN_CONTINUE
	}
	
	new ent = g_PlayerTurretMove[id] , 
	Float:fOrigin[3], entlist[3]

	entity_get_vector(ent, EV_VEC_origin, fOrigin)
	
	if(getClosestTurret(ent, 60.0, 1)) {
		client_print(id, print_center,"%L", id, "CREATE_TURRET_TOO_CLOSE")
		menuBuyTurretH(id, 0, Type-1)
		return PLUGIN_CONTINUE
	}
	else if(find_sphere_class(ent, "func_illusionary", 10.0, entlist, 2)) {
		client_print(id, print_center, "%L", id, "CREATE_TURRET_NO_HERE")
		menuBuyTurretH(id, 0, Type-1)
		return PLUGIN_CONTINUE
	}
	else if(!fm_is_ent_visible(id, ent)) {
		client_print(id, print_center, "%L", id, "CREATE_TURRET_NO_HERE")
		menuBuyTurretH(id, 0, Type-1)
		return PLUGIN_CONTINUE		
	}
			
			
	TurretRangerTurnOff(g_PlayerTurretMove[id])
	
	if(is_valid_ent(g_PlayerTurretMove[id]))
		remove_entity(g_PlayerTurretMove[id])
		
	g_PlayerTurretMove[id] = 0
	
	CreateTurret(id, turret, Type)
	
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	
	return PLUGIN_CONTINUE		
}

public CreateMoveEffectTurret(id , e_TurretsType:iTurretType, iTurretEnt)
{
	if(!is_user_alive(id) || iTurretType == TURRET_NONE)
		return
		
	new Float:fOrigin[3], Float:Angles[3]
	entity_get_vector(id, EV_VEC_origin, fOrigin)

	get_origin_from_dist_player(id, 70.0, fOrigin)

	if(!is_valid_ent(iTurretEnt)) {
		new iEnt  = create_entity("func_wall")
		
		entity_set_string(iEnt, EV_SZ_classname, "turret")
		entity_set_model(iEnt, "models/TD/sentrygun_2.mdl")
		entity_set_vector(iEnt, EV_VEC_origin, fOrigin)
		
		fm_set_rendering(iEnt, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 255)
		
		entity_set_int(iEnt, EV_INT_solid, SOLID_NOT)
	
		new iRanger = create_entity("env_sprite")
		
		entity_set_edict(iEnt, EV_ENT_turret_ranger, iRanger)
		
		entity_set_string(iRanger, EV_SZ_classname, "ranger")
		entity_set_model(iRanger, g_SpriteRanger)
		entity_set_edict(iRanger, EV_ENT_turret_owner, id)
		/* Angle */
		
		entity_get_vector(iRanger, EV_VEC_angles, Angles)
		Angles[0] += 90
		
		fOrigin[2] += 1.0
		
		entity_set_origin(iRanger, fOrigin)
		entity_set_vector(iRanger, EV_VEC_angles, Angles)
		
		entity_set_float(iRanger, EV_FL_scale, g_TurretsRangeData[iTurretType][0]/250.0)
		fm_set_rendering(iRanger, kRenderFxNone, 0, 255, 0, kRenderTransAdd, 255)
		
		entity_set_int(iRanger, EV_INT_ranger_status, 2)
		g_PlayerTurretMove[id] = iEnt
	}
	else {		
		entity_set_model(iTurretEnt, "models/TD/sentrygun_2.mdl")
		entity_set_vector(iTurretEnt, EV_VEC_origin, fOrigin)
		
		new iRanger = create_entity("env_sprite")
		
		entity_set_edict(iTurretEnt, EV_ENT_turret_ranger, iRanger)
		
		fm_set_rendering(iTurretEnt, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 255)
		
		entity_set_string(iRanger, EV_SZ_classname, "ranger")
		entity_set_model(iRanger, g_SpriteRanger)
		entity_set_edict(iRanger, EV_ENT_turret_owner, id)
		
		/* Angle */
		
		entity_get_vector(iRanger, EV_VEC_angles, Angles)
		Angles[0] += 90
		
		fOrigin[2] += 1.0
		
		entity_set_origin(iRanger, fOrigin)
		entity_set_vector(iRanger, EV_VEC_angles, Angles)
		
		entity_set_float(iRanger, EV_FL_scale, g_TurretsRangeData[iTurretType][g_PlayerTurretRangeLevel[id][entity_get_int(iTurretEnt, EV_INT_turret_id)]]/250.0)
		fm_set_rendering(iRanger, kRenderFxNone, 0, 255, 0, kRenderTransAdd, 255)
		entity_set_int(iRanger, EV_INT_ranger_status, 2)
		g_PlayerTurretMove[id] = iTurretEnt
	}
		
}

public menuTurret(id, turret) {
	if(!is_user_alive(id)) {
		return PLUGIN_CONTINUE
	}
		
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	
	new szTitle[256], szFormat[64];
	
	TurretRangerTurnOn(g_PlayerTurretEnt[id][turret])
	
	new e_TurretsType:type = e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret],EV_INT_turret_type)
	
	formatex(szTitle,255, "\r[\y %s \r] [\y %s\r ]^n%L %L^n%L %L", 
	g_szTurretsShopName[turret], g_szTurretsName[type], id, "T_LEVEL", g_PlayerTurretLevel[id][turret],id, "T_AMMO",  g_PlayerTurretAmmo[id][turret]?  g_PlayerTurretAmmo[id][turret]:0,
	id, "T_DAMAGE", g_TurretsDamageData[type][g_PlayerTurretDamageLevel[id][turret]][0], g_TurretsDamageData[type][g_PlayerTurretDamageLevel[id][turret]][1],
	id, "T_RANGE", g_TurretsRangeData[type][g_PlayerTurretRangeLevel[id][turret]])
	
	new iMenu = menu_create(szTitle, "menuTurretH")
	new cb = menu_makecallback("menuTurretCb")
	
	new szData[4];
	num_to_str(turret, szData, 3)
	
	if(type == TURRET_NORMAL)
		formatex(szFormat, 63, "%L",id, "T_BUY_AMMO", g_CvarValue[TURRET_NORMAL_AMMO_NUM], g_CvarValue[TURRET_NORMAL_AMMO])
	if(type == TURRET_LASER)
		formatex(szFormat, 63, "%L",id, "T_BUY_AMMO", g_CvarValue[TURRET_LASER_AMMO_NUM], g_CvarValue[TURRET_LASER_AMMO])
	if(type == TURRET_LIGHTING)
		formatex(szFormat, 63, "%L",id, "T_BUY_AMMO", g_CvarValue[TURRET_LIGHTING_AMMO_NUM], g_CvarValue[TURRET_LIGHTING_AMMO])
	
	menu_additem(iMenu, szFormat, szData, _, cb);
	
	formatex(szFormat, 33, "%L", id, "T_DELETE_T")
	menu_additem(iMenu, szFormat, _, _, cb);
	
	formatex(szFormat, 63, "%L", id, "T_MOVE_T", g_CvarValue[TURRET_MOVE_COST])
	menu_additem(iMenu, szFormat, _, _, cb)
	
	if(g_PlayerTurretIsUpgrading[id][turret])
		formatex(szFormat, 63, "%L", id, "T_STILL_UPGRADING")
	else 
		formatex(szFormat, 63, "%L", id, "T_UPGRADE_T")
	menu_additem(iMenu, szFormat, _, _, cb)
	
	formatex(szFormat, 63, "%L", id, "BACK")
	menu_setprop(iMenu, MPROP_EXITNAME, szFormat)
	
	menu_display(id, iMenu);
	return PLUGIN_CONTINUE
}

public menuTurretCb(id, menu, item)
{
	new cb, acces, szName[3], szData[4]
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	new e_TurretsType:type = e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)
	
	new gold = _:td_get_user_info(id, PLAYER_GOLD)
	
	if(g_PlayerTurretIsUpgrading[id][turret])
		return ITEM_DISABLED
		
	if(item == 0)
	{
		if(type == TURRET_NORMAL)
		{
			if(g_CvarValue[TURRET_NORMAL_AMMO] > gold)
				return ITEM_DISABLED
		}
		else if(type == TURRET_LASER)
		{
			if(g_CvarValue[TURRET_LASER_AMMO] > gold)
				return ITEM_DISABLED
		}
		else if(type == TURRET_LIGHTING)
		{
			if(g_CvarValue[TURRET_LIGHTING_AMMO] > gold)
				return ITEM_DISABLED
		}
	}
	else if(item == 2 && gold < g_CvarValue[TURRET_MOVE_COST])
		return ITEM_DISABLED
		
	return ITEM_ENABLED
}

public menuTurretH(id, menu, item) {
	
	new cb, acces, szName[3], szData[4]
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	if(item == MENU_EXIT ) {
		
		TurretRangerTurnOff(g_PlayerTurretEnt[id][turret])
		menu_destroy(menu)
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	
	new e_TurretsType:type = e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)
	if(item == 0)
	{
		switch(type) {
			case TURRET_NORMAL: {
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-g_CvarValue[TURRET_NORMAL_AMMO])
				g_PlayerTurretAmmo[id][turret] += g_CvarValue[TURRET_NORMAL_AMMO_NUM]+1
			}
			case TURRET_LASER: {
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-g_CvarValue[TURRET_LASER_AMMO])
				g_PlayerTurretAmmo[id][turret] += g_CvarValue[TURRET_LASER_AMMO_NUM]+1
			}
			case TURRET_LIGHTING: {
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-g_CvarValue[TURRET_LIGHTING_AMMO])
				g_PlayerTurretAmmo[id][turret] += g_CvarValue[TURRET_LIGHTING_AMMO_NUM]+1
			}
		}
		menu_destroy(menu)
		
		ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix, id, "T_RELOADING",  (g_CvarValue[TURRET_RELOAD_TIME] - g_fPlayerExtraTime[id]) ? (g_CvarValue[TURRET_RELOAD_TIME] - g_fPlayerExtraTime[id]) : 0.1)
		
		TurretRangerTurnOff(g_PlayerTurretEnt[id][turret])
		if(g_PlayerTurretAmmo[id][turret] > g_iPlayerAlarmValue[id]) {
			g_PlayerAlarmStatus[id][turret] = false;
		}
		
		entity_set_float(g_PlayerTurretEnt[id][turret], EV_FL_nextthink, (get_gametime() + g_CvarValue[TURRET_RELOAD_TIME] - g_fPlayerExtraTime[id]) ? (get_gametime() + g_CvarValue[TURRET_RELOAD_TIME] - g_fPlayerExtraTime[id]) : 0.1);
		g_PlayerTurretIsUpgrading[id][turret] = true
		
		new szData[4]
		szData[0] = id
		szData[1] = turret
		
		set_task((g_CvarValue[TURRET_RELOAD_TIME] - g_fPlayerExtraTime[id]) ? (g_CvarValue[TURRET_RELOAD_TIME] - g_fPlayerExtraTime[id]) : 0.1, "turretReloadPost", id + TASK_RELOAD_AMMO, szData, 3)
		menuUpgradeTurretUpgrading(id)
		
		ChangeAmmoBar(g_PlayerTurretEnt[id][turret], -2, 0)
		
		client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	}
	else if(item == 1) {
		menu_destroy(menu)
		menuConfirmDelete(id, turret)
	}
	else if(item == 2) {
		new Float:fOrigin[3]
		entity_get_vector(g_PlayerTurretEnt[id][turret], EV_VEC_origin, fOrigin)
		
		new iEnt = getClosestTurret(id, 60.0, 0)
		
		if(iEnt) {
			if(iEnt == g_PlayerTurretEnt[id][turret]) {
				entity_set_vector(g_PlayerTurretEnt[id][turret], EV_VEC_oldorigin, fOrigin)
				menuMoveTurret(id, g_PlayerTurretEnt[id][turret])
			} else {
				client_print(id, print_center, "%L", id, "T_MOVE_ERROR_1")
				menuTurret(id, turret);
			}
		}
		else  {
			client_print(id, print_center, "%L", id, "T_MOVE_ERROR_2")
			menuTurret(id, turret);

		}
	}
	else if(item == 3) {
		menu_destroy(menu)
		menuUpgradeTurret(id, turret)
	}
	return PLUGIN_CONTINUE
}

public turretReloadPost(szData[], iTask)
{
	new id = szData[0]
	new turret = szData[1]
	
	remove_task(iTask - id)
	g_PlayerTurretIsUpgrading[id][turret] = false
	ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix,id, "T_RELOAD_INFO", g_PlayerTurretAmmo[id][turret])
	menuTurret(id, turret)
}

public menuConfirmDelete(id, turret){
	TurretRangerTurnOff(g_PlayerTurretEnt[id][turret])
	
	static szFormat[128];
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_CONFIRM_DELETE_TITLE")
	new iMenu = menu_create(szFormat, "menuConfirmDeleteH")
	
	new szData[4]
	num_to_str(turret, szData, 3)
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "YES")
	menu_additem(iMenu, szFormat, szData)
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "BACK")
	menu_additem(iMenu, szFormat)
	
	menu_setprop(iMenu, MPROP_EXITNAME,szFormat)
	
	menu_display(id, iMenu)
	
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
}

public menuConfirmDeleteH(id, menu, item){
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	
	new cb, acces, szName[3], szData[4]
	
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	if(item == MENU_EXIT || item == 1){
		if(is_user_alive(id)) {
			menu_destroy(menu)
			menuTurret(id, turret)
		}
		return PLUGIN_CONTINUE
	}
	else if(item == 0) {
		menu_destroy(menu)
		DeleteTurret(id, g_PlayerTurretEnt[id][turret])
	}
	
	return PLUGIN_CONTINUE
}

public menuMoveTurret(id, ent){		
			
	if(!_td_is_turret(ent)) {
		return PLUGIN_CONTINUE
	}
		
	if(!is_user_alive(id))
		return PLUGIN_CONTINUE
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	
	entity_set_float(ent, EV_FL_nextthink, 0.0)
	
	if(!g_PlayerTurretMove[id]) {
		
		TurretRangerTurnOff(ent)
		RemoveAmmoBar(ent)
		CreateMoveEffectTurret(id, e_TurretsType:g_PlayerTurretType[id][entity_get_int(ent, EV_INT_turret_id)], ent)
	}
	new szFormat[64];
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_TURRET_MOVE_TITLE", g_CvarValue[TURRET_MOVE_COST])
	new menu = menu_create(szFormat, "menuMoveTurretH")
	
	new szData[4];
	num_to_str(entity_get_int(ent, EV_INT_turret_id), szData, 3)
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_TURRET_MOVE_THERE")
	menu_additem(menu, szFormat, szData)
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "BACK")
	menu_additem(menu, szFormat)
	
	menu_setprop(menu, MPROP_EXITNAME, szFormat)
	menu_display(id, menu)
	
	return PLUGIN_CONTINUE
}

public menuMoveTurretH(id, menu, item)
{
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	
	new cb, acces, szName[3], szData[4]
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	if(item == MENU_EXIT || item == 1 || !is_user_alive(id)) {
		
		g_PlayerTurretMove[id] = 0
		
		new Float:fOrigin[3]
		
		TurretRangerTurnOff(g_PlayerTurretEnt[id][turret])
		
		entity_get_vector(g_PlayerTurretEnt[id][turret], EV_VEC_oldorigin, fOrigin)
		entity_set_vector(g_PlayerTurretEnt[id][turret], EV_VEC_origin, fOrigin)
		drop_to_floor(g_PlayerTurretEnt[id][turret])
		
		CreateAmmoBar(g_PlayerTurretEnt[id][turret])
		
		new szModel[64];
		formatex(szModel, 63, "models/TD/sentrygun_%d.mdl", g_PlayerTurretLevel[id][turret])
		entity_set_model(g_PlayerTurretEnt[id][turret], szModel)
		
		entity_set_float(g_PlayerTurretEnt[id][turret], EV_FL_nextthink, (get_gametime() +  g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) ? (get_gametime() +  g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) : 0.1)
		
		ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix,  id, "T_MOVE_ACTIVATION", g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id])
		
		g_PlayerTurretIsUpgrading[id][turret] = true
		
		fm_set_rendering(g_PlayerTurretEnt[id][turret], kRenderFxNone, 0, 0, 0, kRenderTransAlpha, 255)
		menu_destroy(menu)
		menuUpgradeTurretUpgrading(id)
		new szData[4]
		szData[0] = id
		szData[1] = turret
		
		set_task((g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) ? (g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) : 0.1, "moveTurretPostInfo", (id + TASK_MOVE_TURRET), szData, 3)
		
		return PLUGIN_CONTINUE
		
	}
	else if(item == 0) {
		new Float:fOrigin[3]
		new Origin[3]
		
		get_origin_from_dist_player(id, 70.0, fOrigin)
		FVecIVec(fOrigin, Origin)
		
		new ent = g_PlayerTurretEnt[id][turret], entlist[3]
		
		if(getClosestTurret(ent, 60.0, 1)) {
			client_print(id, print_center,"%L", id, "CREATE_TURRET_TOO_CLOSE")
			menu_destroy(menu)
			menuMoveTurret(id, ent)
			return PLUGIN_CONTINUE
		}
		else if(find_sphere_class(ent, "func_illusionary", 10.0, entlist, 2)) {
			client_print(id, print_center, "%L", id, "CREATE_TURRET_NO_HERE")
			menu_destroy(menu)
			menuMoveTurret(id, ent)
			return PLUGIN_CONTINUE
		}
		else if(!fm_is_ent_visible(id, ent)) {
			client_print(id, print_center, "%L", id, "CREATE_TURRET_NO_HERE")
			menu_destroy(menu)
			menuMoveTurret(id, ent)
			return PLUGIN_CONTINUE		
		}
		g_PlayerTurretMove[id] = 0
		
		TurretRangerTurnOff(ent)
		CreateAmmoBar(ent)
		
		//to
		message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) 
		write_byte(TE_TELEPORT)
		write_coord(Origin[0]) 
		write_coord(Origin[1])
		write_coord(Origin[2])
		message_end()
		
		FVecIVec(fOrigin, Origin)
		
		//from
		message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) 
		write_byte(TE_TELEPORT)
		write_coord(Origin[0]) 
		write_coord(Origin[1])
		write_coord(Origin[2])
		message_end()
		
		entity_set_origin(ent, fOrigin)
		drop_to_floor(ent)
		
		new szModel[64];
		formatex(szModel, 63, "models/TD/sentrygun_%d.mdl", g_PlayerTurretLevel[id][turret])
		entity_set_model(ent, szModel)
		
		entity_set_float(ent, EV_FL_nextthink, (get_gametime() +  g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) ? (get_gametime() +  g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) : get_gametime() + 0.1)
		g_PlayerTurretIsUpgrading[id][turret] = true
		
		fm_set_rendering(ent, kRenderFxNone, 0, 0, 0, kRenderTransAlpha, 255)
		ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix,  id, "T_MOVE_ACTIVATION", (g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) ? (g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) : 0.1)
		
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-g_CvarValue[TURRET_MOVE_COST])
		menu_destroy(menu)
		menuUpgradeTurretUpgrading(id)
		
		new szData[4]
		szData[0] = id
		szData[1] = turret
		
		set_task((g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) ? (g_CvarValue[TURRET_MOVE_ACTIVATION] - g_fPlayerExtraTime[id]) : 0.1, "moveTurretPostInfo", id + TASK_MOVE_TURRET, szData, 3)
		
	}
	return PLUGIN_CONTINUE
}

public moveTurretPostInfo(szData[], iTask)
{
	new id = szData[0]
	new turret = szData[1]
	
	remove_task(id, iTask-id)
	g_PlayerTurretIsUpgrading[id][turret] = false
	ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix, id, "T_READY")
	
	menuTurret(id, turret)
}

public DeleteTurret(id, iEnt)
{
	if(!is_valid_ent(iEnt))
		return PLUGIN_CONTINUE	
	else if(!_td_is_turret(iEnt))
		return PLUGIN_CONTINUE

	new Float:fOrigin[3], Origin[3]
	entity_get_vector(iEnt, EV_VEC_origin, fOrigin)
	FVecIVec(fOrigin, Origin)

	message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) //message begin
	write_byte(TE_IMPLOSION)
	write_coord(Origin[0]) // start position
	write_coord(Origin[1])
	write_coord(Origin[2]+30)
	write_byte(100) 
	write_byte(45) 
	write_byte(5) 
	message_end()

	new sentryid = entity_get_int(iEnt, EV_INT_turret_id)

	DeleteTurretRanger(g_PlayerTurretEnt[id][sentryid])
	RemoveAmmoBar(iEnt)
	
	g_PlayerTurretType[id][sentryid] = TURRET_NONE
	g_PlayerTurretEnt[id][sentryid] = 0
	g_PlayerTurretLevel[id][sentryid] = 0
	g_PlayerTurretAmmo[id][sentryid] = 0
	g_PlayerTurretNum[id]--
	g_iServerTurretsNum--

	g_PlayerAlarmStatus[id][sentryid] = false
	g_PlayerTurretIsUpgrading[id][sentryid] = false
	
	g_PlayerTurretDamageLevel[id][sentryid] = 0
	g_PlayerTurretRangeLevel[id][sentryid] = 0

	entity_set_edict(iEnt, EV_ENT_turret_owner, 0)
	entity_set_edict(iEnt, EV_ENT_turret_ammobar, 0)
	entity_set_edict(iEnt, EV_ENT_turret_ranger, 0)
	
	entity_set_int(iEnt, EV_INT_turret_id, 0)
	entity_set_int(iEnt, EV_INT_turret_type, 0)
	entity_set_int(iEnt, EV_INT_turret_firemode, 0)
	entity_set_int(iEnt, EV_INT_turret_target, 0)

	entity_set_float(iEnt, EV_FL_nextthink, 0.0);
	
	remove_entity(iEnt)
	
	cmdmenuTurrets(id)
	
	remove_task(iEnt)

	return PLUGIN_CONTINUE
}

public menuUpgradeTurret(id, turret) {
	if(!is_user_alive(id)) 
		return PLUGIN_CONTINUE
	
	client_cmd(id, "spk sound/%s", g_Sounds[SOUND_MENU_SELECT]);
	
	static szFormat[256]

	TurretRangerTurnOn(g_PlayerTurretEnt[id][turret])

	new e_TurretsType:type = e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)
	new damage_level = g_PlayerTurretDamageLevel[id][turret]
	new range_level = g_PlayerTurretRangeLevel[id][turret]

	formatex(szFormat, charsmax(szFormat), "\r[\y %s \r] [\y %s\r ]^n%L^n%L %L", 
	g_szTurretsShopName[turret], g_szTurretsName[type], id, "T_LEVEL",  g_PlayerTurretLevel[id][turret],
	id, "T_DAMAGE", g_TurretsDamageData[type][damage_level][0], g_TurretsDamageData[type][damage_level][1],
	id, "T_RANGE", g_TurretsRangeData[type][range_level])
	
	new menu = menu_create(szFormat, "menuUpgradeTurretH")
	new cb = menu_makecallback("menuUpgradeTurretCb")
	
	new szData[4]
	num_to_str(turret, szData, 3)
	
	if(damage_level+1 >= g_TurretsMaxLevelData[type][0])
		formatex(szFormat,   charsmax(szFormat), "%L", id, "T_UPGRADE_DAMAGE_FULL")
	else if(damage_level < g_TurretsMaxLevelData[type][0])
		formatex(szFormat,   charsmax(szFormat), "%L", id, "T_UPGRADE_DAMAGE", g_TurretsPriceData[type][damage_level+1],
		(g_TurretsDamageData[type][damage_level+1][0] - g_TurretsDamageData[type][damage_level][0]), 
		(g_TurretsDamageData[type][damage_level+1][1] - g_TurretsDamageData[type][damage_level][1]))
	
	menu_additem(menu, szFormat, szData,_,cb)
	
	if(range_level+1 >= g_TurretsMaxLevelData[type][1])
		formatex(szFormat,   charsmax(szFormat), "%L", id, "T_UPGRADE_RANGE_FULL")
	else if(range_level < g_TurretsMaxLevelData[type][1])
		formatex(szFormat,   charsmax(szFormat), "%L",id, "T_UPGRADE_RANGE",  g_TurretsPriceData[type][range_level+1],
		(g_TurretsRangeData[type][range_level+1] - g_TurretsRangeData[type][range_level]))
	
	menu_additem(menu, szFormat,_,_,cb)

	formatex(szFormat, charsmax(szFormat), "%L", id, "BACK");
	menu_setprop(menu, MPROP_EXITNAME, szFormat)
	
	menu_display(id, menu)

	return PLUGIN_CONTINUE
}
public menuUpgradeTurretCb(id, menu, item) {
	new cb, acces, szName[3], szData[4]
	menu_item_getinfo(menu, 0, acces, szData, 3, szName, 2, cb)
	
	new turret = str_to_num(szData);
	
	if((item == 0 && g_PlayerTurretDamageLevel[id][turret]+1 >= g_TurretsMaxLevelData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)][0])
	|| (item == 0 && (g_TurretsPriceData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)][g_PlayerTurretDamageLevel[id][turret]+1]) > td_get_user_info(id, PLAYER_GOLD)))
		return ITEM_DISABLED
	if((item == 1 && g_PlayerTurretRangeLevel[id][turret]+1 >= g_TurretsMaxLevelData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)][1])
	|| (item == 1 && (g_TurretsPriceData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)][g_PlayerTurretRangeLevel[id][turret]+1]) > td_get_user_info(id, PLAYER_GOLD)))
		return ITEM_DISABLED
	
	return ITEM_ENABLED
}

public menuUpgradeTurretH(id, menu, item) {	
	new cb, acces, szName[3], szDataItem[4]
	menu_item_getinfo(menu, 0, acces, szDataItem, 3, szName, 2, cb)
	
	new turret = str_to_num(szDataItem);
	
	if(item == MENU_EXIT || !is_user_alive(id)) {
		TurretRangerTurnOff(g_PlayerTurretEnt[id][turret])
		menu_destroy(menu)
		menuTurret(id, turret)
		return PLUGIN_CONTINUE
	}
	else if(item == 0) {	// damage
		g_PlayerTurretDamageLevel[id][turret]++
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-g_TurretsPriceData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)][g_PlayerTurretDamageLevel[id][turret]])
		
	}
	else if(item == 1) {	// range
		g_PlayerTurretRangeLevel[id][turret]++
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-g_TurretsPriceData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][turret], EV_INT_turret_type)][g_PlayerTurretRangeLevel[id][turret]])
	}
	
	ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix,id, "CMD_UPGRADE_TURRET", g_CvarValue[TURRET_UPGRADE_TIME]);

	TurretRangerTurnOff(g_PlayerTurretEnt[id][turret])
	
	new szData[4]
	szData[0] = id
	szData[1] = item
	szData[2] = turret
	
	ChangeAmmoBar(g_PlayerTurretEnt[id][turret], 5, 1)
	
	entity_set_float(g_PlayerTurretEnt[id][turret], EV_FL_nextthink, (get_gametime() + g_CvarValue[TURRET_UPGRADE_TIME] - g_fPlayerExtraTime[id]) ? (get_gametime() + g_CvarValue[TURRET_UPGRADE_TIME] - g_fPlayerExtraTime[id]) : 0.1)
	g_PlayerTurretIsUpgrading[id][turret] = true;
	
	set_task((g_CvarValue[TURRET_UPGRADE_TIME] - g_fPlayerExtraTime[id]) ? (g_CvarValue[TURRET_UPGRADE_TIME] - g_fPlayerExtraTime[id]) : 0.1, "menuUpgradeTurretPost",id +  TASK_UPGRADE_TURRET, szData, 3)
	
	menu_destroy(menu)
	menuUpgradeTurretUpgrading(id)
	
	return PLUGIN_CONTINUE
}

public menuUpgradeTurretPost(szData[], iTask) {	
	new id = szData[0]
	new item = szData[1] // 0 - damage | 1 - range
	new sentry = szData[2]
	
	remove_task(iTask - id)
	
	g_PlayerTurretIsUpgrading[id][sentry] = false
	
	if(item == 0) {	// damage
		ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix, id, "T_P_UPGRADE_DAMAGE", g_TurretsDamageData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][sentry], EV_INT_turret_type)][g_PlayerTurretDamageLevel[id][sentry]][0], g_TurretsDamageData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][sentry], EV_INT_turret_type)][g_PlayerTurretDamageLevel[id][sentry]][1])
	} else if(item == 1) { // range
		ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix, id, "T_P_UPGRADE_RANGE", g_TurretsRangeData[ e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][sentry], EV_INT_turret_type) ][ g_PlayerTurretRangeLevel[id][sentry] ])		
	}
	
	new iPrevLvl = g_PlayerTurretLevel[id][sentry]
	
	g_PlayerTurretLevel[id][sentry] = floatround(1 +( g_PlayerTurretDamageLevel[id][sentry] + g_PlayerTurretRangeLevel[id][sentry]) / ((g_TurretsMaxLevelData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][sentry], EV_INT_turret_type)][0] + g_TurretsMaxLevelData[e_TurretsType:entity_get_int(g_PlayerTurretEnt[id][sentry], EV_INT_turret_type)][1]) / 5.0), floatround_floor)
	
	if(!g_PlayerTurretLevel[id][sentry]) g_PlayerTurretLevel[id][sentry] += 1
	if(iPrevLvl != g_PlayerTurretLevel[id][sentry]) {
		ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix, id, "T_LEVEL_UP", g_PlayerTurretLevel[id][sentry])
	}

	new szModel[64];
	formatex(szModel, 63, "models/TD/sentrygun_%d.mdl", g_PlayerTurretLevel[id][sentry])
	
	entity_set_model(g_PlayerTurretEnt[id][sentry], szModel)
	
	entity_get_string(g_PlayerTurretEnt[id][sentry], EV_SZ_classname, szModel, 63)
	menuUpgradeTurret(id, sentry)
}

public menuUpgradeTurretUpgrading(id)
{
	if(!is_user_alive(id)) 
		return PLUGIN_CONTINUE
	
	new szFormat[33];
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_UPGRADING_TITLE")
	new iMenu = menu_create(szFormat, "menuUpgradeTurretUpgradingH");
	new iCb = menu_makecallback("menuUpgradeTurretUpgradingCb")
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_UPGRADING_ITEM")
	menu_additem(iMenu, szFormat,_,_, iCb)
	menu_additem(iMenu, szFormat,_,_,iCb)
	
	formatex(szFormat, charsmax(szFormat), "%L", id, "MENU_UPGRADING_EXIT")
	menu_setprop(iMenu, MPROP_EXITNAME, szFormat)
	menu_display(id, iMenu)

	return PLUGIN_CONTINUE
}

public menuUpgradeTurretUpgradingCb(id, menu, item)
	return ITEM_DISABLED

public menuUpgradeTurretUpgradingH(id, menu, item){
	if(item == MENU_EXIT)
		menu_destroy(menu);
}

public CreateTurretRangerEntity(iTurret) {
	if(!_td_is_turret(iTurret)) 
		return PLUGIN_CONTINUE;
	
	new Float:fAngles[3]
	new iRanger = create_entity("env_sprite")
	
	entity_set_edict(iTurret, EV_ENT_turret_ranger, iRanger)
	entity_set_edict(iRanger, EV_ENT_turret_owner, entity_get_edict(iTurret, EV_ENT_turret_owner))
	
	entity_set_string(iRanger, EV_SZ_classname, "ranger")
	entity_set_model(iRanger, g_SpriteRanger)
	
	
	
	entity_get_vector(iRanger, EV_VEC_angles, fAngles)
	fAngles[0] += 90
	entity_set_vector(iRanger, EV_VEC_angles,fAngles)
	
	fm_set_rendering(iRanger, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 0)
	
	return PLUGIN_CONTINUE
}
public TurretRangerTurnOn(iTurret) {
	if(!_td_is_turret(iTurret)) 
		return PLUGIN_CONTINUE
	
	new iRanger = entity_get_edict(iTurret, EV_ENT_turret_ranger)
	
	new Float:fOrigin[3]

	/* Polozenie */
	entity_get_vector(iTurret, EV_VEC_origin, fOrigin)
	fOrigin[2] += 1.0	
	entity_set_vector(iRanger, EV_VEC_origin,fOrigin)
	
	/* Wielko?a */
	
	new iLevel = g_PlayerTurretRangeLevel[entity_get_edict(iTurret, EV_ENT_turret_owner)][entity_get_int(iTurret, EV_INT_turret_id)]
	new iRange = g_TurretsRangeData[e_TurretsType:entity_get_int(iTurret, EV_INT_turret_type)][iLevel]
	
	entity_set_float(iRanger, EV_FL_scale, iRange/250.0)
	
	/* Widoczno?a */
	
	entity_set_int(iRanger, EV_INT_ranger_status, 1)
	fm_set_rendering(iRanger, kRenderFxNone, 0, 255, 0, kRenderTransAdd, 255)
	
	return PLUGIN_CONTINUE
}

public TurretRangerTurnOff(iTurret) {
	
	new iRanger = entity_get_edict(iTurret, EV_ENT_turret_ranger)
	
	if(_td_is_ranger(iRanger)) {
		entity_set_int(iRanger, EV_INT_ranger_status, 0)
		fm_set_rendering(iRanger, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 0)
	}
	
	return PLUGIN_CONTINUE
}

public DeleteTurretRanger(iTurret) {
	
	new iRanger = entity_get_edict(iTurret, EV_ENT_turret_ranger)
	
	if(_td_is_ranger(iRanger)) {
		entity_set_int(iRanger, EV_INT_ranger_status, 0)
		entity_set_edict(iRanger, EV_ENT_turret_owner,0)
		entity_set_edict(iTurret, EV_ENT_turret_ranger, 0)	
		
		remove_entity(iRanger);
	}
}

public CreateTurret(id, sentryid, type) {
	
	g_PlayerTurretMove[id] = 0
	
	new Float:fOrigin[3];
	new iEntList[3]
	
	get_origin_from_dist_player(id, 70.0, fOrigin)
	
	if(find_sphere_class(0, "turret", 60.0, iEntList, 2, fOrigin)) {
		client_print(id, print_center,"%L", id, "CREATE_TURRET_TOO_CLOSE")
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	else if(find_sphere_class(0, "func_illusionary", 10.0, iEntList, 2, fOrigin)) {
		client_print(id, print_center, "%L", id, "CREATE_TURRET_NO_HERE")
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	
	new iEnt = create_entity("info_target")

	entity_set_string(iEnt, EV_SZ_classname, "turret");
	entity_set_model(iEnt, "models/TD/sentrygun_1.mdl");
	
	entity_set_size(iEnt, Float:{-16.0, -16.0, 0.0}, Float:{16.0, 16.0, 48.0});
	entity_set_origin(iEnt, fOrigin);
	
	entity_set_vector(iEnt, EV_VEC_angles, Float:{0.0, 0.0, 0.0});
	entity_set_byte(iEnt, EV_BYTE_controller2, 127);
	//entity_set_float(iEnt, EV_FL_takedamage, DAMAGE_YES);
	//entity_set_float(iEnt, EV_FL_health, 99999.9)
	
	entity_set_edict(iEnt, EV_ENT_turret_owner, id)
	entity_set_int(iEnt, EV_INT_turret_id, sentryid)
	entity_set_int(iEnt, EV_INT_turret_type, type)
	entity_set_int(iEnt, EV_INT_turret_firemode, 1)
	
	drop_to_floor(iEnt)

	g_PlayerTurretType[id][sentryid] = e_TurretsType:type
	g_PlayerTurretEnt[id][sentryid] = iEnt
	
	g_PlayerTurretLevel[id][sentryid] = 1
	g_PlayerTurretDamageLevel[id][sentryid] = 0
	g_PlayerTurretRangeLevel[id][sentryid] = 0
	
	
	switch(e_TurretsType:type) {
		case TURRET_NORMAL : {
			g_PlayerTurretAmmo[id][sentryid] =100
		}
		case TURRET_LASER: {
			g_PlayerTurretAmmo[id][sentryid] = 50
		}
		case TURRET_LIGHTING: {
			g_PlayerTurretAmmo[id][sentryid] = 150
		}
	}
	
	g_PlayerTurretNum[id]++
	g_iServerTurretsNum++
	g_PlayerTurretIsUpgrading[id][sentryid] = true
	
	CreateAmmoBar(iEnt)
	CreateTurretRangerEntity(iEnt);
	
	emit_sound(id, CHAN_AUTO, g_Sounds[SOUND_TURRET_PLANT], 1.0, ATTN_NORM, 0, PITCH_NORM);
	
	td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD) - g_TurretsPriceData[e_TurretsType:type][0])
	ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix, id, "T_INSTALL_TURRET", (g_CvarValue[TURRET_INSTALL_TIME] - g_fPlayerExtraTime[id] ) ? (g_CvarValue[TURRET_INSTALL_TIME] - g_fPlayerExtraTime[id]) : 0.1)
	
	new szData[4]
	szData[0] = id
	szData[1] = iEnt
	szData[2] = sentryid
	
	set_task((g_CvarValue[TURRET_INSTALL_TIME] - g_fPlayerExtraTime[id]), "CreateTurretFinishInfo", id+TASK_CREATE_TURRET_INFO, szData, 3)
	entity_set_float(iEnt, EV_FL_nextthink, (get_gametime() + g_CvarValue[TURRET_INSTALL_TIME] - g_fPlayerExtraTime[id]) ? (get_gametime() + g_CvarValue[TURRET_INSTALL_TIME] - g_fPlayerExtraTime[id]) : 0.1);
	
	menuUpgradeTurretUpgrading(id)
	return PLUGIN_CONTINUE
}
	
public CreateTurretFinishInfo(szData[], iTask){
	new id = szData[0]
	remove_task(iTask - id)
	
	g_PlayerTurretIsUpgrading[id][szData[2]] = false
	
	ColorChat(id, GREEN, "%s^x01 %L", g_szPrefix, id, "T_READY")
	
	cmdmenuTurrets(id)
}

public TurretThink(ent) {
	if(!is_valid_ent(ent))
		return PLUGIN_CONTINUE
	
	new e_TurretsType:iType = e_TurretsType:entity_get_int(ent, EV_INT_turret_type)
	new iPlayer = entity_get_edict(ent, EV_ENT_turret_owner)
	new iSentry = entity_get_int(ent, EV_INT_turret_id)
	new iShoot = entity_get_int(ent, EV_INT_turret_firemode)
	new iTarget = entity_get_int(ent, EV_INT_turret_target)
	
	static Float:TurretOrigin[3]
	static Float:TargetOrigin[3]
	static ammo 
	ammo = g_PlayerTurretAmmo[iPlayer][iSentry]
	
	if(g_PlayerTurretIsUpgrading[iPlayer][iSentry]) {
		g_PlayerTurretIsUpgrading[iPlayer][iSentry] = false
	}
	ChangeAmmoBar(ent, ammo, 0)
	
	
	/* Bug fix #1
		If turret was placed ex. on box, and the box was hitted,
		turret will (if random_num == 1) dropped to floor, and it ammobar
	*/
	if(random_num(1, 75) == 1) {
		drop_to_floor(ent)
		new ammobar = entity_get_edict(ent, EV_ENT_turret_ammobar)
		if(is_valid_ent(ammobar)) {
			new Float:fOrigin[3]
			entity_get_vector(ent, EV_VEC_origin, fOrigin)
			fOrigin[2] += 63
			entity_set_origin(ammobar, fOrigin)
		}
	}
	/* ******** */
	
	/* Nie strzelaj */
	if(ammo == 0) {
		new iRet;
		ExecuteForward(g_ForwardNoAmmo, iRet, iPlayer, ent, iSentry)
		if(iRet)
			return iRet
		
		emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_NOAMMO], 1.0, ATTN_NORM, 0, PITCH_NORM);
		
		ColorChat(iPlayer, GREEN, "%s^x01 %L", g_szPrefix, iPlayer, "T_NO_AMMO")
		client_cmd(iPlayer, "spk sound/%s", g_Sounds[SOUND_TURRET_NOAMMO]);
		
		g_PlayerTurretAmmo[iPlayer][iSentry]--
		return PLUGIN_CONTINUE
	}
	
	/* ============ */
	
	if(iShoot && is_valid_ent(iTarget)) 
	{
		if(!fm_is_ent_visible(ent, iTarget) || entity_get_int(iTarget, EV_INT_iuser1) == 0) 
		{
			fireoff:
			iShoot = 0
			entity_set_int(ent, EV_INT_turret_firemode, 0)
			entity_set_int(ent, EV_INT_turret_target, 0)
			emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_STOP_FIRE], 1.0, ATTN_NORM, 0, PITCH_NORM);
			
			entity_set_float(ent, EV_FL_nextthink, get_gametime()+0.1);
			return PLUGIN_CONTINUE
		}
		
		entity_get_vector(iTarget, EV_VEC_origin, TargetOrigin)
		entity_get_vector(ent, EV_VEC_origin, TurretOrigin)
		
		if(get_distance_f(TargetOrigin, TurretOrigin) > g_TurretsRangeData[iType][g_PlayerTurretRangeLevel[iPlayer][iSentry]])
			goto fireoff;
		
			
		TurretTurnToTarget(ent, iTarget);
		
		TurretOrigin[2] += 45.0
		
		g_PlayerTurretAmmo[iPlayer][iSentry]--
		
		if(ammo == g_iPlayerAlarmValue[iPlayer])
		{
			new iRet;
			ExecuteForward(g_ForwardLowAmmo, iRet, iPlayer, ent, iSentry)
			if(iRet)
				return iRet
		
			ColorChat(iPlayer, GREEN, "%s^x01 %L", g_szPrefix, iPlayer, "T_ALARM")
			g_PlayerAlarmStatus[iPlayer][iSentry] = true;
			
			client_cmd(iPlayer, "spk sound/%s", g_Sounds[SOUND_TURRET_LOWAMMO]);
			emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_LOWAMMO], 1.0, ATTN_NORM, 0, PITCH_NORM);
		}
		
		switch(iType) {
			case TURRET_NORMAL: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_NORMAL_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_NORMAL_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
			case TURRET_LASER: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_LASER_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_LASER_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
			case TURRET_LIGHTING: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_LIGHTING_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_LIGHTING_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
		}
		switch(iType) {
			case TURRET_NORMAL: {
				message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
				write_byte(TE_TRACER);
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				message_end();
				
				createShell(ent, TurretOrigin, 1)
			}
			case TURRET_LASER: {
				message_begin(MSG_BROADCAST ,SVC_TEMPENTITY)
				write_byte(TE_BEAMPOINTS)
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				write_short(g_SpriteLaserBeam)
				write_byte(0)
				write_byte(0)
				write_byte(1) // time
				write_byte(6*(g_PlayerTurretLevel[iPlayer][iSentry])) // grubosc
				write_byte(1)
				switch(g_PlayerTurretLevel[iPlayer][iSentry]) {
					case 1: {
						write_byte(255)
						write_byte(255)
						write_byte(255)
					} 
					case 2: {
						write_byte(0)
						write_byte(255)
						write_byte(0)
					}
					case 3: {
						write_byte(255)
						write_byte(255)
						write_byte(0)
					} 
					case 4: {
						write_byte(255)
						write_byte(0)
						write_byte(0)
					} 
					case 5:{
						write_byte(0)
						write_byte(0)
						write_byte(255)
					}
				}
				write_byte(255)
				write_byte(5)
				message_end()
			}
			case TURRET_LIGHTING: {
				message_begin(MSG_BROADCAST ,SVC_TEMPENTITY)
				write_byte(TE_BEAMPOINTS)
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				write_short(g_SpriteLaserBeam)
				write_byte(0)
				write_byte(0)
				write_byte(1) // time
				write_byte(10) // grubosc
				write_byte(16)
				switch(g_PlayerTurretLevel[iPlayer][iSentry]) {
					case 1: {
						write_byte(255)
						write_byte(255)
						write_byte(255)
					} 
					case 2: {
						write_byte(0)
						write_byte(255)
						write_byte(0)
					}
					case 3: {
						write_byte(255)
						write_byte(255)
						write_byte(0)
					} 
					case 4: {
						write_byte(255)
						write_byte(0)
						write_byte(0)
					} 
					case 5:{
						write_byte(0)
						write_byte(0)
						write_byte(255)
					}
				}
				write_byte(255)
				write_byte(5) //szybkosc
				message_end()
			}	
		}
		
		/* Take damage to monster */
		switch(random_num(1, 4)) 
		{
			case 1, 2, 3: {
				new Float:dmg = random_float(float(g_TurretsDamageData[iType][g_PlayerTurretDamageLevel[iPlayer][iSentry]][0]),float(g_TurretsDamageData[iType][g_PlayerTurretDamageLevel[iPlayer][iSentry]][1])) + g_PlayerTurretLevel[iPlayer][iSentry]
				ExecuteHamB(Ham_TakeDamage, iTarget, iPlayer, iPlayer, dmg, DMG_DROWN, 1);
			}
			case 4: {
				// If turret miss | missed.wav ?
			}
		}
		
		/* Thinki */
		
		switch(iType) {
			case TURRET_NORMAL: 	entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (g_TurretsFreqData[TURRET_NORMAL]/100.0));
			case TURRET_LASER: 	entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (g_TurretsFreqData[TURRET_LASER]/100.0));
			case TURRET_LIGHTING:	entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (g_TurretsFreqData[TURRET_LIGHTING]/100.0));
		}
		
		return PLUGIN_CONTINUE	
	}
	else
		iShoot = 0
		
	iTarget = TurretGetClosestMonster(ent)

	if(iTarget && fm_is_ent_visible(ent, iTarget))
	{
		emit_sound(ent, CHAN_AUTO, g_Sounds[SOUND_TURRET_START_FIRE], 1.0, ATTN_NORM, 0, PITCH_NORM);
		TurretTurnToTarget(ent, iTarget);
		
		entity_set_int(ent, EV_INT_turret_target, iTarget)
		entity_set_int(ent, EV_INT_turret_firemode, 1)
		
		entity_set_float(ent, EV_FL_nextthink, get_gametime() + g_CvarValue[TURRET_CHANGE_ENEMY_TIME]);
		return PLUGIN_CONTINUE
	}
	
	/*  Freeze time  */
	if(!iShoot) {
		
		new controler1 = entity_get_byte(ent, EV_BYTE_controller1)+2;
		if(controler1 > 255)
			controler1 = 0;
		entity_set_byte(ent, EV_BYTE_controller1, controler1);
			
		new controler2 = entity_get_byte(ent, EV_BYTE_controller2);
		if(controler2 > 127 || controler2 < 127)
			entity_set_byte(ent, EV_BYTE_controller2, 127);
		

		entity_set_float(ent, EV_FL_nextthink, get_gametime() + 0.25);
	}
	return PLUGIN_CONTINUE
}

stock TurretTurnToTarget(ent, enemy, mode = 0, Float:enemyOrigin[3] = {0.0, 0.0, 0.0})
{
	static Float:sentryOrigin[3], Float:closestOrigin[3]
	entity_get_vector(ent, EV_VEC_origin, sentryOrigin)
	
	if(enemyOrigin[0] == 0.0 && enemyOrigin[1] == 0.0 && enemyOrigin[2] == 0.0)
		entity_get_vector(enemy, EV_VEC_origin, closestOrigin)
	else
		closestOrigin = enemyOrigin
		
	new newTrip, Float:newAngle = floatatan(((closestOrigin[1]-sentryOrigin[1])/(closestOrigin[0]-sentryOrigin[0])), radian) * 57.2957795;

	if(closestOrigin[0] < sentryOrigin[0])
		newAngle += 180.0;
	if(newAngle < 0.0)
		newAngle += 360.0;
	
	sentryOrigin[2] += 35.0
	if(closestOrigin[2] > sentryOrigin[2])
		newTrip = 0;
	if(closestOrigin[2] < sentryOrigin[2])
		newTrip = 255;
	if(closestOrigin[2] == sentryOrigin[2])
		newTrip = 127;
		
	entity_set_byte(ent, EV_BYTE_controller1, floatround(newAngle*0.70833));
	entity_set_byte(ent, EV_BYTE_controller2, newTrip);
	
	if(!mode)
		entity_set_byte(ent, EV_BYTE_controller3, entity_get_byte(ent, EV_BYTE_controller3)+20>255? 0: entity_get_byte(ent, EV_BYTE_controller3)+20);
}

public TurretGetClosestMonster(ent) {
	new Float:flDistanse = float( g_TurretsRangeData[e_TurretsType:entity_get_int(ent, EV_INT_turret_type)][g_PlayerTurretRangeLevel[entity_get_edict(ent, EV_ENT_turret_owner)][entity_get_int(ent, EV_INT_turret_id)]])
	new Float:fOrigin1[3];
	new Float:fOrigin2[3]
	
	entity_get_vector(ent, EV_VEC_origin, fOrigin1)
	
	new tempEntID;
	new entlist[6]
	new Float:dis;
	for(new i ; i < find_sphere_class(ent, "monster", flDistanse, entlist, 5) ; i++) 
	{	if(entity_get_int(entlist[i], EV_INT_iuser1) == 0)
			continue
		
		entity_get_vector(entlist[i], EV_VEC_origin, fOrigin2);
		
		dis = get_distance_f(fOrigin1, fOrigin2)
		if(dis < flDistanse) {
			flDistanse = dis;
			tempEntID = entlist[i];
		}	
	}
	return tempEntID;
}

public LoadSound() {
	new szText[128], len;
	new szTemp[3][128];

	if(!file_exists(g_szSoundConfigFile)) {
		log_to_file(g_szLogFile, "TURRETS: Sounds configuration file not found...")
		return PLUGIN_CONTINUE
	}
	
	for(new i ; read_file(g_szSoundConfigFile, i, szText, 127, len) ; i++)
	{
		if(equali(szText, ";") || equali(szText, ""))
			continue;
			
		parse(szText, szTemp[0], 127, szTemp[1], 16, szTemp[2], 127)
		remove_quotes(szTemp[2]);
		
		if(equali(szTemp[0], "TURRET_NORMAL_FIRE_1")) 
			copy(g_Sounds[SOUND_TURRET_NORMAL_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_NORMAL_FIRE_2")) 
			copy(g_Sounds[SOUND_TURRET_NORMAL_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LASER_FIRE_1")) 
			copy(g_Sounds[SOUND_TURRET_LASER_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LASER_FIRE_2")) 
			copy(g_Sounds[SOUND_TURRET_LASER_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LIGHTING_FIRE_1")) 
			copy(g_Sounds[SOUND_TURRET_LIGHTING_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LIGHTING_FIRE_2")) 
			copy(g_Sounds[SOUND_TURRET_LIGHTING_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_START_FIRE")) 
			copy(g_Sounds[SOUND_TURRET_START_FIRE], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_STOP_FIRE")) 
			copy(g_Sounds[SOUND_TURRET_STOP_FIRE], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_PLANT")) 
			copy(g_Sounds[SOUND_TURRET_PLANT], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LOW_AMMO")) 
			copy(g_Sounds[SOUND_TURRET_LOWAMMO], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_NO_AMMO")) 
			copy(g_Sounds[SOUND_TURRET_NOAMMO], 127, szTemp[2])
		else if(equali(szTemp[0], "MENU_SELECT")) 
			copy(g_Sounds[SOUND_MENU_SELECT], 127, szTemp[2])
	}

	return PLUGIN_CONTINUE
}

public LoadTurretsConfig(szMapName[])
{
	new szText[64], len
	new szData[64], iData[2][6]
	new szFormat[64]
	new iMaxLevel[e_TurretsType][2] // 0 - obrazenia | 1 - zasieg
	server_cmd("exec addons/amxmodx/configs/td_cvars.cfg");
	
	new szDir[80];
	formatex(szDir, charsmax(szDir), "%s/%s.cfg", g_szTurretsConfigDir, szMapName);
	
	if(!file_exists(szDir)) {
		formatex(szDir, charsmax(szDir), "%s/%s", g_szTurretsConfigDir, g_szTurretsDefaultConfigFile)
		
		if(!file_exists(szDir))
		{
			log_to_file(g_szLogFile, "TURRETS : Default turrets config file is not exist: '%s'. Game is not possible ", g_szTurretsDefaultConfigFile)
		
			td_set_game_status(eGame:GAME_NOT_AVAILABLE)
			return PLUGIN_CONTINUE
		}
		log_to_file(g_szLogFile, "TURRETS : There is not exist a turrets configuration file for map: '%s'. Loading standard file. ", szMapName)

	}
	
	for(new i = 0 ; read_file(szDir, i, szText, 63, len); i ++)
	{
		if(szText[0] == ';' || (szText[0] == '/' && szText[1] == '/') || equali(szText, ""))
			continue;
		
		replace_all(szText, 63, "=", "")
		
		parse(szText, szData, 63, iData[0], 5, iData[1], 5)
		
		new iNum = str_to_num(iData[0])
		new iNum2 = str_to_num(iData[1])
		new szCommand[64]
		copy(szCommand, 63, szData)

		if(equali(szData, "NORMAL", 6)) {
			if(equali(szCommand, "NORMAL_TURRET_FIRE_FREQ")) {
				g_TurretsFreqData[TURRET_NORMAL] = iNum
				continue
			}
			replace(szData, 63, "NORMAL_TURRET_RANGE_", "");
			formatex(szFormat, 63, "NORMAL_TURRET_RANGE_%d", str_to_num(szData))

			if(equali(szCommand, szFormat)) {
				iMaxLevel[TURRET_NORMAL][1] ++;
				g_TurretsRangeData[TURRET_NORMAL][str_to_num(szData)-1] = iNum
				continue;
			}
			replace(szData, 63, "NORMAL_TURRET_PRICE_", "");
			formatex(szFormat, 63, "NORMAL_TURRET_PRICE_%d", str_to_num(szData))
			if(equali(szCommand, szFormat)) {
				g_TurretsPriceData[TURRET_NORMAL][str_to_num(szData)-1] = iNum
				continue;
			}
			replace(szData, 63, "NORMAL_TURRET_DMG_", "");
			formatex(szFormat, 63, "NORMAL_TURRET_DMG_%d", str_to_num(szData))
			if(equali(szCommand, szFormat)) {
				g_TurretsDamageData[TURRET_NORMAL][str_to_num(szData)-1][0] = iNum
				g_TurretsDamageData[TURRET_NORMAL][str_to_num(szData)-1][1] = iNum2
				iNum2 = 0
				iMaxLevel[TURRET_NORMAL][0] ++;
				continue;
			}
		}
		else if(equali(szData, "LASER", 5)) {
			if(equali(szCommand, "LASER_TURRET_FIRE_FREQ")) {
				g_TurretsFreqData[TURRET_LASER] = iNum
				continue
			}
			replace(szData, 63, "LASER_TURRET_RANGE_", "");
			formatex(szFormat, 63, "LASER_TURRET_RANGE_%d", str_to_num(szData))
			if(equali(szCommand, szFormat)) {
				g_TurretsRangeData[TURRET_LASER][str_to_num(szData)-1] = iNum
				iMaxLevel[TURRET_LASER][1] ++;
				continue;
			}
			replace(szData, 63, "LASER_TURRET_PRICE_", "");
			formatex(szFormat, 63, "LASER_TURRET_PRICE_%d", str_to_num(szData))
			if(equali(szCommand, szFormat)) {
				g_TurretsPriceData[TURRET_LASER][str_to_num(szData)-1] = iNum
				continue;
			}
			replace(szData, 63, "LASER_TURRET_DMG_", "");
			formatex(szFormat, 63, "LASER_TURRET_DMG_%d", str_to_num(szData))
			if(equali(szCommand, szFormat)) {
				g_TurretsDamageData[TURRET_LASER][str_to_num(szData)-1][0] = iNum
				g_TurretsDamageData[TURRET_LASER][str_to_num(szData)-1][1] = iNum2
				iNum2 = 0
				iMaxLevel[TURRET_LASER][0] ++;
				continue;
			}
		}
		else if(equali(szData, "LIGHTING", 8)) {	
			if(equali(szCommand, "LIGHTING_TURRET_FIRE_FREQ")) {
				g_TurretsFreqData[TURRET_LIGHTING] = iNum
				continue
			}
			replace(szData, 63, "LIGHTING_TURRET_RANGE_", "");
			formatex(szFormat, 63, "LIGHTING_TURRET_RANGE_%d", str_to_num(szData))
			if(equali(szCommand, szFormat)) {
				g_TurretsRangeData[TURRET_LIGHTING][str_to_num(szData)-1] = iNum
				iMaxLevel[TURRET_LIGHTING][1] ++;
				continue;
			}
			replace(szData, 63, "LIGHTING_TURRET_PRICE_", "");
			formatex(szFormat, 63, "LIGHTING_TURRET_PRICE_%d", str_to_num(szData))
			if(equali(szCommand, szFormat)) {
				g_TurretsPriceData[TURRET_LIGHTING][str_to_num(szData)-1] = iNum
				continue;
			}
			replace(szData, 63, "LIGHTING_TURRET_DMG_", "");
			formatex(szFormat, 63, "LIGHTING_TURRET_DMG_%d", str_to_num(szData))
			if(equali(szCommand, szFormat)) {
				g_TurretsDamageData[TURRET_LIGHTING][str_to_num(szData)-1][0] = iNum
				g_TurretsDamageData[TURRET_LIGHTING][str_to_num(szData)-1][1] = iNum2
				iNum2 = 0
				iMaxLevel[TURRET_LIGHTING][0] ++;
				continue;
			}
		}	
	}
	MAX_MAP_TURRET = clamp(td_get_max_map_turrets(), 1, MAX_SERVER_TURRET)
	
	for(new i; i < _:e_TurretsType ; i++){
		g_TurretsMaxLevelData[e_TurretsType:i][0] = iMaxLevel[e_TurretsType:i][0]
		g_TurretsMaxLevelData[e_TurretsType:i][1] = iMaxLevel[e_TurretsType:i][1]
	}

	return PLUGIN_CONTINUE;
}

stock createShell(index, Float:fOrigin[3], num) {
	for(new i; i < num;i++) {
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY, {0.0, 0.0, 0.0}, index);
		write_byte(TE_MODEL);
		write_coord(floatround(fOrigin[0]));
		write_coord(floatround(fOrigin[1]));
		write_coord(floatround(fOrigin[2]));
		write_coord(random_num(-100,100));
		write_coord(random_num(-100,100));
		write_coord(random_num(100,200));
		write_angle(random_num(0,360));
		write_short(g_ShellIndex);
		write_byte(0);
		write_byte(100);
		message_end()
	}
}

stock get_origin_from_dist_player(id, Float:dist, Float:origin[3], s3d = 1) {
	new Float:idorigin[3];
	entity_get_vector(id, EV_VEC_origin, idorigin); // lub pev(id, pev_origin, idorigin) dla fakemety
	
	if(dist == 0) {
		origin = idorigin;
		return;
	}
	
	new Float:idvangle[3];
	entity_get_vector(id, EV_VEC_v_angle, idvangle); // lub pev(id, pev_v_angle, idvangle) dla fakemety
	idvangle[0] *= -1;
	
	origin[0] = idorigin[0] + dist * floatcos(idvangle[1], degrees) * ((s3d) ? floatabs(floatcos(idvangle[0], degrees)) : 1.0);
	origin[1] = idorigin[1] + dist * floatsin(idvangle[1], degrees) * ((s3d) ? floatabs(floatcos(idvangle[0], degrees)) : 1.0);
	origin[2] = idorigin[2]
}

public ChangeAlarmValue(id, iValue) {
	g_iPlayerAlarmValue[id] = iValue
	
	for(new i ; i < MAX_PLAYER_TURRET ; i++) {	
		if(g_PlayerTurretAmmo[id][i] > iValue){
			g_PlayerAlarmStatus[id][i] = false
		}
	}
}

public _get_alarm_value(index)
	return g_iPlayerAlarmValue[index]
	
public CreateAmmoBar(Turret)
{
	if(!_td_is_turret(Turret) || g_CvarValue[TURRET_SHOW_AMMO_BAR]== 0)
		return
	new Float:Origin[3]
	entity_get_vector(Turret, EV_VEC_origin, Origin)
	
	new sprite = create_entity("env_sprite")
	
	entity_set_edict(Turret, EV_ENT_turret_ammobar, sprite)
	entity_set_string(sprite, EV_SZ_classname, "ammobar")
	entity_set_model(sprite, g_SpriteAmmoBar)
	entity_set_edict(sprite, EV_ENT_turret_owner, entity_get_edict(Turret, EV_ENT_turret_owner))
	Origin[2]+=63
	
	entity_set_origin(sprite, Origin)
	entity_set_float(sprite, EV_FL_scale, 0.3)
}

public ChangeAmmoBarScale(id, Float:fScale) {
	g_fPlayerAmmoBarScale[id] = fScale;	
}

public ChangeAmmoBar(turret, ammo, upgrading )
{
	if(g_CvarValue[TURRET_SHOW_AMMO_BAR] == 0) {
		RemoveAmmoBar(turret)
		return;
	}
	new ammobar = entity_get_edict(turret, EV_ENT_turret_ammobar)
	if(!is_valid_ent(ammobar))
		CreateAmmoBar(turret)

	if(!td_is_ammobar(ammobar))
		return ;

	static R,G,B
	if(ammo >= 500) {
		R = 0
		G = 255
		B = 0
	}
	else if(ammo < 500 && ammo >= 450) {
		R = 34
		G = 255
		B = 0
	}
	else if(ammo < 450 && ammo >= 400) {
		R = 70
		G = 255
		B = 0
	}
	else if(ammo < 400 && ammo >= 350) {
		R = 120
		G = 255
		B = 0
	}
	else if(ammo < 350 && ammo >= 300) {
		R = 170
		G = 255
		B = 0
	}
	else if(ammo < 300 && ammo >= 250) {
		R = 210
		G = 255
		B = 0
	}
	else if(ammo < 250 && ammo >= 200) {
		R = 255
		G = 255
		B = 0
	}
	else if(ammo < 200 && ammo >= 150) {
		R = 238
		G = 200
		B = 0
	}
	else if(ammo < 150 && ammo >= 125) {
		R = 255
		G = 150
		B = 0
	}
	else if(ammo < 125 && ammo >= 100) {
		R = 255
		G = 125
		B = 0
	}
	else if(ammo < 100 && ammo >= 75) {
		R = 255
		G = 100
		B = 0
	}
	else if(ammo < 75 && ammo >= 50) {
		R = 255
		G = 75
		B = 0
	}
	else if(ammo < 50 && ammo >= 25) {
		R = 255
		G = 50
		B = 0
	}
	else if(ammo < 25 && ammo >= 10) {
		R = 255
		G = 25
		B = 0
	}
	else if(ammo < 10 && ammo >= -1) {
		R = 255
		G = 0
		B = 0
	}
	else if(ammo < -1) {
		R = 0
		G = 0
		B = 255
	}
	if(upgrading) {
		R = 4
		B = 134
		G = 8
	}
	if(is_valid_ent(ammobar)) {
		fm_set_rendering(ammobar, kRenderFxNone, R, G, B, kRenderTransAdd, 255)
	}
}

public ChangeRangerColor(ranger, r, g, b) {
	if(!_td_is_ranger(ranger))
		return
	
	fm_set_rendering(ranger, kRenderFxNone, r, g, b, kRenderTransAdd, 255)
}

public RemoveAmmoBar(turret) {
	if(is_valid_ent(entity_get_edict(turret, EV_ENT_turret_ammobar))) {

		entity_set_edict(entity_get_edict(turret, EV_ENT_turret_ammobar), EV_ENT_turret_owner, 0)
		remove_entity(entity_get_edict(turret, EV_ENT_turret_ammobar))
	}
}

public e_TurretsType:_get_player_turret_type(index, turret)
	return g_PlayerTurretType[index][turret]
public _set_player_turret_type(index, turret, e_TurretsType:type)
	g_PlayerTurretType[index][turret] = type

public bool:_get_player_turret_slot(index, turret)
	return g_PlayerSlot[index][turret]
public _set_player_turret_slot(index, turret, value)
	g_PlayerSlot[index][turret] = bool:value

public bool:_turret_is_upgrading(index, turret)
	return g_PlayerTurretIsUpgrading[index][turret]

public _get_turret_entity(index, turret)
	return g_PlayerTurretEnt[index][turret]

public _get_turret_level(index, turret)
	return g_PlayerTurretLevel[index][turret]
public _get_turret_damage_level(index, turret)
	return g_PlayerTurretDamageLevel[index][turret]
public _get_turret_range_level(index, turret)
	return g_PlayerTurretRangeLevel[index][turret]

public _get_turret_ammo(index, turret)
	return g_PlayerTurretAmmo[index][turret]
public _set_turret_ammo(index, turret, value)
	g_PlayerTurretAmmo[index][turret] = value

public bool:_is_moving_turret(index)
	return bool:g_PlayerTurretMove[index]
public _get_moved_turret_entity(index)
	return g_PlayerTurretMove[index]

public _get_turrets_num(index)
	return g_PlayerTurretNum[index]

public _get_turret_target(turret_entity, index, turret)
	return entity_get_int(turret_entity?turret_entity:g_PlayerTurretEnt[index][turret], EV_INT_turret_target)
public _get_turret_owner(turret_entity, index, turret)
	return entity_get_edict(turret_entity?turret_entity:g_PlayerTurretEnt[index][turret], EV_ENT_turret_owner)
public _td_get_turret_ammobar(turret_entity, index, turret)
	return entity_get_edict(turret_entity?turret_entity:g_PlayerTurretEnt[index][turret], EV_ENT_turret_ammobar)
public _get_turret_ranger(turret_entity, index, turret)
	return entity_get_edict(turret_entity?turret_entity:g_PlayerTurretEnt[index][turret], EV_ENT_turret_ranger)
public _get_turret_ranger_status(turret_entity, index, turret)
	return entity_get_int(turret_entity?turret_entity:g_PlayerTurretEnt[index][turret], EV_INT_ranger_status)
public _get_turret_id(turret_entity, index, turret)
	return entity_get_int(turret_entity?turret_entity:g_PlayerTurretEnt[index][turret], EV_INT_turret_id)

public get_max_turrets_per_player()
	return MAX_PLAYER_TURRET
public get_max_server_turrets()
	return MAX_SERVER_TURRET
public bool:_get_turret_alarm_status(index, turret)
	return g_PlayerAlarmStatus[index][turret]
public _td_is_turret(iEnt) {
	if(!is_valid_ent(iEnt))
		return 0;
	
	new classname[10]
	entity_get_string(iEnt, EV_SZ_classname, classname, 9)
	if(equali(classname, "turret"))
		return 1;
	return 0;
}


public _td_is_ranger(iEnt)
{
	if(!is_valid_ent(iEnt))
		return 0;
	
	new classname[8]
	entity_get_string(iEnt, EV_SZ_classname, classname, 7)
	if(equali(classname, "ranger"))
		return 1;
	return 0;
}

public _td_is_ammobar(iEnt)
{
	if(!is_valid_ent(iEnt))
		return 0;
	
	new classname[11]
	entity_get_string(iEnt, EV_SZ_classname, classname, 10)
	if(equali(classname, "ammobar"))
	{
		return 1;
	}
	return 0;
}

public Float:_td_get_player_extra_time(id)
	return g_fPlayerExtraTime[id]

public Float:_td_set_player_extra_time(id, Float:fTime)
	g_fPlayerExtraTime[id] = fTime


public _td_is_turret_on_server() {
	return g_iServerTurretsNum ? 1 : 0
}

public _td_is_ranger_exists(iEnt) {	
	if(is_valid_ent(entity_get_edict(iEnt, EV_ENT_turret_ranger)))
		return 1;
	return 0;
}
