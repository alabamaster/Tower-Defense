/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <fakemeta_util>
#include <hamsandwich>
#include <xs>
#include <td>

#pragma dynamic 32768 

#define PLUGIN "TD Turrets: New"
#define VERSION "1.0"
#define AUTHOR "GT Team"

#define MAX_PLAYER_TURRET 2
#define MAX_SERVER_TURRET 20

#define pev_turret_id 		pev_iuser1
#define pev_turret_type 	pev_iuser2
#define pev_turret_firemode 	pev_iuser3
#define pev_turret_target	pev_iuser4
#define pev_turret_owner 	pev_owner
#define pev_turret_ranger	pev_euser3

new gszTurretsConfigFile[] = "addons/amxmodx/configs/td_turrets_config.cfg"
new gszSoundConfigFile[] = "addons/amxmodx/configs/td_sounds.cfg";
new gszLogFile[] = "Tower Defense.log"
new gszPrefix[] = "[TD:T]"

native max_map_turrets()

new MAX_MAP_TURRET

enum e_TurretsType {
	TURRET_NONE,
	TURRET_NORMAL,
	TURRET_LASER,
	TURRET_LIGHTING
}

enum e_Sound {
	SOUND_TURRET_NORMAL_FIRE_1,
	SOUND_TURRET_NORMAL_FIRE_2,
	SOUND_TURRET_LASER_FIRE_1,
	SOUND_TURRET_LASER_FIRE_2,
	SOUND_TURRET_LIGHTING_FIRE_1,
	SOUND_TURRET_LIGHTING_FIRE_2,
	SOUND_TURRET_START_FIRE,
	SOUND_TURRET_STOP_FIRE,
	SOUND_TURRET_PLANT,
	SOUND_TURRET_LOWAMMO,
	SOUND_TURRET_NOAMMO,
	SOUND_MENU_SELECT
}

enum e_Cvars {
	CVAR_TURRET_NORMAL_AMMO,
	CVAR_TURRET_LASER_AMMO,
	CVAR_TURRET_LIGHTING_AMMO,
	CVAR_TURRET_NORMAL_AMMO_NUM,
	CVAR_TURRET_LASER_AMMO_NUM,
	CVAR_TURRET_LIGHTING_AMMO_NUM,
	CVAR_TURRET_MOVE_COST
}
	
new const gszTurretsName[e_TurretsType][] =
{
	"BRAK",
	"ZWYKLA",
	"LASER",
	"PIORUN"
}

new const gszTurretsShopName[MAX_PLAYER_TURRET][] = {
	"Wiezyczka 1",
	"Wiezyczka 2"
}

new const giSlotCost[MAX_PLAYER_TURRET] = {
	10,
	25
}

new gServerTurretsNum
new gTurretsFreqData[e_TurretsType]
new gTurretsPriceData[e_TurretsType][5]
new gTurretsDamageData[e_TurretsType][5][2]
new gTurretsRangeData[e_TurretsType][5]

new gCvarInfo[e_Cvars]
new gSounds[e_Sound][128]

new e_TurretsType:gPlayerTurretType[33][MAX_PLAYER_TURRET]
new bool:gPlayerSlot[33][MAX_PLAYER_TURRET]
new gPlayerTurretEnt[33][MAX_PLAYER_TURRET]
new gPlayerTurretLevel[33][MAX_PLAYER_TURRET]
new gPlayerTurretDamageLevel[33][MAX_PLAYER_TURRET]
new gPlayerTurretRangeLevel[33][MAX_PLAYER_TURRET]
new gPlayerTurretAmmo[33][MAX_PLAYER_TURRET]
new gPlayerTurretNum[33]; 

new gSpriteLaserBeam;
new gSpriteRanger[] = "sprites/TD/ranger.spr"
new gShellIndex
public plugin_precache() 
{
	LoadSound()
	for(new i; i < _:e_Sound ; i++) {
		precache_sound(gSounds[e_Sound:i]);
	}
	precache_model("models/TD/sentrygun_1.mdl")
	precache_model("models/TD/sentrygun_2.mdl")
	precache_model("models/TD/sentrygun_3.mdl")
	precache_model("models/TD/sentrygun_4.mdl")
	precache_model("models/TD/sentrygun_5.mdl")
	
	gShellIndex = precache_model("models/rshell_big.mdl")
	gSpriteLaserBeam = precache_model("sprites/TD/laserbeam.spr")
	precache_model(gSpriteRanger)
	
}
public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)

	if(td_get_game_status() == GAME_NOT_AVAILABLE)
		set_fail_state("Gra jest niemozliwa");
		
	register_forward(FM_AddToFullPack, "fwAddToFullPack", 1)
	
	register_think("turret", "TurretThink")
	register_clcmd("say /turrets", "cmdmenuTurrets");
	
	/* Cvary */
	gCvarInfo[CVAR_TURRET_NORMAL_AMMO] = register_cvar("td_turret_normal_ammo_cost", "15")
	gCvarInfo[CVAR_TURRET_LASER_AMMO] = register_cvar("td_turret_laser_ammo_cost", "20")
	gCvarInfo[CVAR_TURRET_LIGHTING_AMMO] = register_cvar("td_turret_lighting_ammo_cost", "25")
	
	gCvarInfo[CVAR_TURRET_NORMAL_AMMO_NUM] = register_cvar("td_turret_normal_ammo_num", "250")
	gCvarInfo[CVAR_TURRET_LASER_AMMO_NUM] = register_cvar("td_turret_laser_ammo_num", "100")
	gCvarInfo[CVAR_TURRET_LIGHTING_AMMO_NUM] = register_cvar("td_turret_lighting_ammo_num", "400")
	
	gCvarInfo[CVAR_TURRET_MOVE_COST] = register_cvar("td_turret_move_cost", "10")
	
	LoadTurretsConfig()
}
public fwAddToFullPack(es_handle, e, ENT, HOST, hostflags, player, set)
{
	if(player || !is_user_connected(HOST) || !is_valid_ent(ENT)) 
		return FMRES_IGNORED;
		

	
	if(td_is_ranger(ENT))
	{	
		if(pev(ENT, pev_turret_owner) == HOST)
		{
			set_es(es_handle, ES_RenderMode, kRenderTransAdd)
			set_es(es_handle, ES_RenderAmt, 255)
			set_es(es_handle, ES_RenderColor, 0, 0, 0)
			set_es(es_handle, ES_RenderFx, kRenderFxNone)
		}
		else
		{
			set_es(es_handle, ES_RenderMode, kRenderTransAdd)
			set_es(es_handle, ES_RenderAmt, 0)
			set_es(es_handle, ES_RenderColor, 0, 0, 0)
			set_es(es_handle, ES_RenderFx, kRenderFxNone)
			//fm_set_rendering(pev(ENT, pev_turret_ranger), kRenderFxNone, 0, 0, 0, kRenderTransAdd, 0)
		}
	}
	
	return FMRES_IGNORED;
}
public cmdmenuTurrets(id) {
	if(!is_user_connected(id)  || !is_user_alive(id))
		return PLUGIN_CONTINUE;
		
	new szFormat[64]
	new menu = menu_create("Wybierz :", "cmdmenuTurretsH")
	new cb = menu_makecallback("cmdmenuTurretsCb");
	
	new iGold = td_get_user_info(id, PLAYER_GOLD)
	for(new i ; i < MAX_PLAYER_TURRET; i++)
	{
		DeleteTurretRanger(gPlayerTurretEnt[id][i])
		if(gServerTurretsNum >= MAX_SERVER_TURRET && gPlayerTurretEnt[id][i] <= 0)
			formatex(szFormat, 63, "Slot %d \r [ LIMIT SERWERA ]", i+1)
		else if(gServerTurretsNum >= MAX_MAP_TURRET && gPlayerTurretEnt[id][i] <= 0)
			formatex(szFormat, 63, "Slot %d \r [ LIMIT MAPY ]", i+1)
		else if(gPlayerSlot[id][i] == false && iGold < giSlotCost[i])
			formatex(szFormat, 63, "Slot %d \r[ %d \yZLOTA\r ]", i+1, giSlotCost[i])
		else if(gPlayerSlot[id][i] == false && iGold >= giSlotCost[i])
			formatex(szFormat, 63, "Slot %d \r[\y KUP SLOT ZA \r%d\y ZLOTA\r ]", i+1, giSlotCost[i])
		/* Jeœli kupi³ slot */
		else if(gPlayerSlot[id][i]) {
			/*Jeœli nie ma kupionej wie¿yczki */
			if(gPlayerTurretEnt[id][i] <= 0)
				formatex(szFormat, 63, "Slot %d \r[\y KUP WIEZYCZKE\r ]", i+1)
			else if(gPlayerTurretEnt[id][i] > 0)
				formatex(szFormat, 63, "%s \r[ \y%d lvl\r ] [ \y%s\r ]", gszTurretsShopName[i], gPlayerTurretLevel[id][i], gszTurretsName[gPlayerTurretType[id][i]])
		}
		
		menu_additem(menu, szFormat, _, _, cb)
	}
	
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz");
	menu_display(id, menu)
	
	return PLUGIN_CONTINUE
}

public cmdmenuTurretsCb(id, menu, item) { 
	new iGold = td_get_user_info(id, PLAYER_GOLD)
	for(new i ; i < MAX_PLAYER_TURRET; i++)
	{	
		if((gServerTurretsNum >= MAX_SERVER_TURRET  || gServerTurretsNum >= MAX_MAP_TURRET) && gPlayerTurretEnt[id][i] <= 0 && item == i)
			return ITEM_DISABLED
		else if(gPlayerSlot[id][i] == false && iGold < giSlotCost[i] && item == i)
			return ITEM_DISABLED
	}
	
	return ITEM_ENABLED
}
public cmdmenuTurretsH(id, menu, item) {
	if(item == MENU_EXIT || !is_user_alive(id)) {
		menu_destroy(menu)
		client_cmd(id, "say /menu")
		return PLUGIN_CONTINUE
	}
	
	if(!gPlayerSlot[id][item]) {
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-giSlotCost[item])
		client_print(id, 3, "%s Kupiles slot %d na wiezyczke. Na tym slocie mozesz posiadac 1 wiezyczke..", gszPrefix, item+1)
		gPlayerSlot[id][item] = true
		
		cmdmenuTurrets(id);
		return PLUGIN_CONTINUE 
	}
	
	if(gPlayerSlot[id][item] && gPlayerTurretEnt[id][item] <= 0) {
		menuBuyTurret(id, item)
	}
	else if(gPlayerSlot[id][item] && gPlayerTurretEnt[id][item] > 0) {
		menuTurret(id, item)
	}
	
	
	return PLUGIN_CONTINUE;
}
new gimenuSentryId[33]
public menuBuyTurret(id, sentryid)
{
	new menu = menu_create("Wybierz typ wiezyczki: ", "menuBuyTurretH")
	new cb = menu_makecallback("menuBuyTurretCb")
	new szFormat[64]
	
	for(new i = 1; i < _:e_TurretsType; i++)
	{
		formatex(szFormat, 63, "%s \r[ \y%d\w ZLOTA\r ]", gszTurretsName[e_TurretsType:i], gTurretsPriceData[e_TurretsType:i][0])
		menu_additem(menu, szFormat, _, _, cb)
	}
	
	gimenuSentryId[id] = sentryid
	
	menu_setprop(menu, MPROP_EXITNAME, "Wroc")
	menu_display(id, menu)
}
public menuBuyTurretCb(id, menu, item)
{
	for(new i = 1; i < _:e_TurretsType; i++)
		if(td_get_user_info(id, PLAYER_GOLD) < gTurretsPriceData[e_TurretsType:i][0] && item == i-1)
			return ITEM_DISABLED
	return ITEM_ENABLED
}

public menuBuyTurretH(id, menu, item)
{
	if(item == MENU_EXIT || !is_user_alive(id))
	{
		gimenuSentryId[id] = 0
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	
	td_set_user_info(id, PLAYER_GOLD, _:td_get_user_info(id, PLAYER_GOLD)-gTurretsPriceData[e_TurretsType:(item+1)][0])
	CreateTurret(id, gimenuSentryId[id], item+1)
	
	return PLUGIN_CONTINUE
}

public menuTurret(id, turret) {
	if(!is_user_alive(id))
		return PLUGIN_CONTINUE
		
	new szTitle[200], szAmmo[64], szDelete[33], szNextMenu[64], szMove[64]
	
	gimenuSentryId[id] = turret
	
	CreateTurretRanger(gPlayerTurretEnt[id][turret])
	
	new e_TurretsType:type = e_TurretsType:pev(gPlayerTurretEnt[id][turret], pev_turret_type)
	
	formatex(szTitle, 199, "\r[\y %s \r] [\y %s\r ]^n[\y Poziom: \w%d\r ] [\y Amunicja: \w%d\r ]^n[\y Zadawane obr: \w%d\y ~\w %d\r ] [ \yZasieg\w %d\r ]", 
	gszTurretsShopName[turret], gszTurretsName[type], gPlayerTurretLevel[id][turret], gPlayerTurretAmmo[id][turret],
	gTurretsDamageData[type][gPlayerTurretDamageLevel[id][turret]][0], gTurretsDamageData[type][gPlayerTurretDamageLevel[id][turret]][1],
	gTurretsRangeData[type][gPlayerTurretRangeLevel[id][turret]])
	
	if(type == TURRET_NORMAL)
		formatex(szAmmo, 63, "Dokup %d amunicji \r[\w %d\y Zlota\r ]", get_pcvar_num(gCvarInfo[CVAR_TURRET_NORMAL_AMMO_NUM]), get_pcvar_num(gCvarInfo[CVAR_TURRET_NORMAL_AMMO]))
	if(type == TURRET_LASER)
		formatex(szAmmo, 63, "Dokup %d amunicji \r[\w %d\y Zlota\r ]", get_pcvar_num(gCvarInfo[CVAR_TURRET_LASER_AMMO_NUM]), get_pcvar_num(gCvarInfo[CVAR_TURRET_LASER_AMMO]))
	if(type == TURRET_LIGHTING)
		formatex(szAmmo, 63, "Dokup %d amunicji \r[\w %d\y Zlota\r ]", get_pcvar_num(gCvarInfo[CVAR_TURRET_LIGHTING_AMMO_NUM]), get_pcvar_num(gCvarInfo[CVAR_TURRET_LIGHTING_AMMO]))
	
	formatex(szNextMenu, 63, "\yUlepsz Wiezyczke")
	formatex(szDelete, 32, "Usun Wiezyczke")
	formatex(szMove, 63, "Przenies Wiezyczke \r[\w %d\y Zlota\r ]", get_pcvar_num(gCvarInfo[CVAR_TURRET_MOVE_COST]))
	
	new menu = menu_create(szTitle, "menuTurretH")
	new cb = menu_makecallback("menuTurretCb")
	menu_additem(menu, szAmmo, _, _, cb);
	menu_additem(menu, szDelete);
	menu_additem(menu, szMove, _, _, cb)
	menu_additem(menu, szNextMenu)
	
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz")
	menu_display(id, menu);
	return PLUGIN_CONTINUE
}
public menuTurretCb(id, menu, item)
{
	new turret = gimenuSentryId[id]
	new e_TurretsType:type = e_TurretsType:pev(gPlayerTurretEnt[id][turret], pev_turret_type)
	new gold = td_get_user_info(id, PLAYER_GOLD)
	if(item == 0)
	{
		if(type == TURRET_NORMAL)
		{
			if(gold <  get_pcvar_num(gCvarInfo[CVAR_TURRET_NORMAL_AMMO]))
				return ITEM_DISABLED
		}
		else if(type == TURRET_LASER)
		{
			if(gold < get_pcvar_num(gCvarInfo[CVAR_TURRET_LASER_AMMO]))
				return ITEM_DISABLED
		}
		else if(type == TURRET_LIGHTING)
		{
			if(gold < get_pcvar_num(gCvarInfo[CVAR_TURRET_LIGHTING_AMMO]))
				return ITEM_DISABLED
		}
	}
	else if(item == 2 && gold < get_pcvar_num(gCvarInfo[CVAR_TURRET_MOVE_COST]))
		return ITEM_DISABLED
		
	return ITEM_ENABLED
}
public menuTurretH(id, menu, item) {
	if(item == MENU_EXIT || !is_user_alive(id)) {
		DeleteTurretRanger(gPlayerTurretEnt[id][gimenuSentryId[id]])
		gimenuSentryId[id] = 0
		if(is_user_alive(id))
			cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	new e_TurretsType:type = e_TurretsType:pev(gPlayerTurretEnt[id][gimenuSentryId[id]], pev_turret_type)
	if(item == 0)
	{
		switch(type)
		{
			case TURRET_NORMAL:
			{
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-get_pcvar_num(gCvarInfo[CVAR_TURRET_NORMAL_AMMO]))
				gPlayerTurretAmmo[id][gimenuSentryId[id]] += get_pcvar_num(gCvarInfo[CVAR_TURRET_NORMAL_AMMO_NUM])+1
			}
			case TURRET_LASER:
			{
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-get_pcvar_num(gCvarInfo[CVAR_TURRET_LASER_AMMO]))
				gPlayerTurretAmmo[id][gimenuSentryId[id]] += get_pcvar_num(gCvarInfo[CVAR_TURRET_LASER_AMMO_NUM])+1
			}
			case TURRET_LIGHTING:
			{
				td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-get_pcvar_num(gCvarInfo[CVAR_TURRET_LIGHTING_AMMO]))
				gPlayerTurretAmmo[id][gimenuSentryId[id]] += get_pcvar_num(gCvarInfo[CVAR_TURRET_LIGHTING_AMMO_NUM])+1
			}
		}
		client_print(id, print_chat, "%s Trwa przeladowywanie wiezyczki...", gszPrefix)
		menuTurret(id, gimenuSentryId[id]);
		entity_set_float(gPlayerTurretEnt[id][gimenuSentryId[id]], EV_FL_nextthink, get_gametime()+3.0);
	}
	else if(item == 1)
		menuConfirmDelete(id)
	else if(item == 2) {
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-get_pcvar_num(gCvarInfo[CVAR_TURRET_MOVE_COST]))
		menuMoveTurret(id, gPlayerTurretEnt[id][gimenuSentryId[id]])
	}
	else if(item == 3)
		menuUpgradeTurret(id)
	return PLUGIN_CONTINUE
}
public menuConfirmDelete(id)
{
	DeleteTurretRanger(gPlayerTurretEnt[id][gimenuSentryId[id]])
	new menu = menu_create("Czy napewno chcesz usunac te wiezyczke?", "menuConfirmDeleteH")
	menu_additem(menu, "\yTak")
	menu_additem(menu, "\rWstecz")
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz")
	menu_display(id, menu)
	
}
public menuConfirmDeleteH(id, menu, item)
{
	if(item == MENU_EXIT || item == 1)
	{
		if(is_user_alive(id))
			menuTurret(id, gimenuSentryId[id])
		return PLUGIN_CONTINUE
	}
	if(item == 0)
		DeleteTurret(id, gPlayerTurretEnt[id][gimenuSentryId[id]])
	return PLUGIN_CONTINUE
}
public menuMoveTurret(id, ent)
{
	if(!td_is_turret(ent) || !is_user_alive(id))
		return PLUGIN_CONTINUE
	
	DeleteTurretRanger(ent)
	entity_set_float(ent, EV_FL_nextthink, 0.0)
	
	new menu = menu_create("", "menuMoveTurretH")
	
	menu_additem(menu, "\yTutaj")
	
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz")
	
	menu_display(id, menu)
	return PLUGIN_CONTINUE
}
public menuMoveTurretH(id, menu, item)
{
	if(item == MENU_EXIT || !is_user_alive(id)) {
		entity_set_float(gPlayerTurretEnt[id][gimenuSentryId[id]], EV_FL_nextthink, get_gametime()+0.5);
		DeleteTurretRanger(gPlayerTurretEnt[id][gimenuSentryId[id]])
		
		if(is_user_alive(id))
			menuTurret(id, gimenuSentryId[id] = 0)
		gimenuSentryId[id] = 0
		return PLUGIN_CONTINUE
	}
	
	if(item == 0)
	{
		new Float:fOrigin[3],Float:fOrigin2[3], Origin[3]
		pev(id, pev_origin, fOrigin)
		FVecIVec(fOrigin, Origin)
		
		new ent = gPlayerTurretEnt[id][gimenuSentryId[id]], entlist[3]
		
		new num = find_sphere_class(-1, "turret", 50.0, entlist, 2, fOrigin)
		if(num > 0)
		{
			if((entlist[0] == ent && entlist[1] != ent))
				goto repair;
			client_print(id, print_center, "Nie mozesz stawiac wiezyczek zbyt blisko siebie!")
			menuMoveTurret(id, ent)
			return PLUGIN_CONTINUE
		}
		num = find_sphere_class(-1, "func_illusionary", 10.0, entlist, 2, fOrigin)
		if(num > 0)
		{
			client_print(id, print_center, "W tym miejscu nie mozna postawic wiezyczki!")
			menuMoveTurret(id, ent)
			return PLUGIN_CONTINUE
		}
		repair:
		//do
		message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) 
		write_byte(TE_TELEPORT)
		write_coord(Origin[0]) 
		write_coord(Origin[1])
		write_coord(Origin[2])
		message_end()
		
		pev(ent, pev_origin, fOrigin2) 
		
		FVecIVec(fOrigin2, Origin)
		//od
		message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) 
		write_byte(TE_TELEPORT)
		write_coord(Origin[0]) 
		write_coord(Origin[1])
		write_coord(Origin[2])
		message_end()
		
		set_pev(ent, pev_origin, fOrigin)
		
		entity_set_float(ent, EV_FL_nextthink, get_gametime()+3.0)
		drop_to_floor(ent)
		
		client_print(id, 3, "%s Twoja wiezyczka uzbroji sie za 3s", gszPrefix)
		
		menuTurret(id, gimenuSentryId[id])
	}
	return PLUGIN_CONTINUE
}
public DeleteTurret(id, iEnt)
{
	if(!is_user_alive(id) || !is_valid_ent(iEnt))
		return PLUGIN_CONTINUE

	new Float:fOrigin[3], Origin[3]
	pev(iEnt, pev_origin, fOrigin)
	FVecIVec(fOrigin, Origin)
	
	message_begin(MSG_BROADCAST ,SVC_TEMPENTITY, Origin, 0) //message begin
	write_byte(TE_IMPLOSION)
	write_coord(Origin[0]) // start position
	write_coord(Origin[1])
	write_coord(Origin[2]+30)
	write_byte(100) 
	write_byte(45) 
	write_byte(5) 
	message_end()

	new sentryid = pev(iEnt, pev_turret_id)
	DeleteTurretRanger(gPlayerTurretEnt[id][sentryid])
	gimenuSentryId[id] = 0
	gPlayerTurretType[id][sentryid] = TURRET_NONE
	gPlayerTurretEnt[id][sentryid] = 0
	gPlayerTurretLevel[id][sentryid] = 0
	gPlayerTurretAmmo[id][sentryid] = 0
	gPlayerTurretNum[id]--
	gServerTurretsNum--
	
	set_pev(iEnt, pev_turret_owner, 0)
	set_pev(iEnt, pev_turret_id, 0)
	set_pev(iEnt, pev_turret_type, 0)
	set_pev(iEnt, pev_turret_firemode, 0)
	entity_set_float(iEnt, EV_FL_nextthink, 0.0);
	
	remove_entity(iEnt)
	cmdmenuTurrets(id)
	return PLUGIN_CONTINUE
}

public menuUpgradeTurret(id)
{
	if(!is_user_alive(id)) 
		return PLUGIN_CONTINUE
		
	new szTitle[200], szDamage[80], szRange[80]
	
	CreateTurretRanger(gPlayerTurretEnt[id][gimenuSentryId[id]])
	
	new turret = gimenuSentryId[id]
	new e_TurretsType:type = e_TurretsType:pev(gPlayerTurretEnt[id][turret], pev_turret_type)
	new damage_level = gPlayerTurretDamageLevel[id][turret]
	new range_level = gPlayerTurretRangeLevel[id][turret]
	
	formatex(szTitle, 199, "\r[\y %s \r] [\y %s\r ]^n[\y Poziom: \w%d\r ]^n[\y Zadawane obr: \w%d\y ~\w %d\r ] [ \yZasieg\w %d\r ]", 
	gszTurretsShopName[turret], gszTurretsName[type], gPlayerTurretLevel[id][turret],
	gTurretsDamageData[type][damage_level][0], gTurretsDamageData[type][damage_level][1],
	gTurretsRangeData[type][range_level])
	
	if(damage_level+1 >= 5)
		formatex(szDamage,  79, "Zwieksz Obrazenia\r [ \yMAX \w~ \yMAX \r]")
	else if(damage_level < 5)
		formatex(szDamage,  79, "Zwieksz Obrazenia\r [ \y%d\w Zlota\r ] [\w +\y%d \w~ \w+\y%d\r ]", gTurretsPriceData[type][damage_level+1],
		(gTurretsDamageData[type][damage_level+1][0] - gTurretsDamageData[type][damage_level][0]), 
		(gTurretsDamageData[type][damage_level+1][1] - gTurretsDamageData[type][damage_level][1]))
	
	if(range_level+1 >= 5)
		formatex(szRange,  63, "Zwieksz Zasieg\r [ \yMAX\r ]")
	else if(range_level < 5)
		formatex(szRange,  63, "Zwieksz Zasieg\r [ \y%d\w Zlota\r ] [\w +\y%d\r ]", gTurretsPriceData[type][range_level+1],
		(gTurretsRangeData[type][range_level+1] - gTurretsRangeData[type][range_level]))
	
	new menu = menu_create(szTitle, "menuUpgradeTurretH")
	new cb = menu_makecallback("menuUpgradeTurretCb")
	
	menu_additem(menu, szDamage,_,_,cb)
	menu_additem(menu, szRange,_,_,cb)
	
	menu_setprop(menu, MPROP_EXITNAME, "Wstecz")
	menu_display(id, menu)
	
	return PLUGIN_CONTINUE
}
public menuUpgradeTurretCb(id, menu, item)
{
	if((item == 0 && gPlayerTurretDamageLevel[id][gimenuSentryId[id]]+1 >= 5)
	|| (item == 0 && (gTurretsPriceData[e_TurretsType:pev(gPlayerTurretEnt[id][gimenuSentryId[id]], pev_turret_type)][gPlayerTurretDamageLevel[id][gimenuSentryId[id]]+1]) > td_get_user_info(id, PLAYER_GOLD)))
		return ITEM_DISABLED
	if((item == 1 && gPlayerTurretRangeLevel[id][gimenuSentryId[id]]+1 >= 5)
	|| (item == 1 && (gTurretsPriceData[e_TurretsType:pev(gPlayerTurretEnt[id][gimenuSentryId[id]], pev_turret_type)][gPlayerTurretRangeLevel[id][gimenuSentryId[id]]+1]) > td_get_user_info(id, PLAYER_GOLD)))
		return ITEM_DISABLED

	return ITEM_ENABLED
}
public menuUpgradeTurretH(id, menu, item)
{
	if(item == MENU_EXIT || !is_user_alive(id))
	{
		DeleteTurretRanger(gPlayerTurretEnt[id][gimenuSentryId[id]])
		if(is_user_alive(id))
			menuTurret(id, gimenuSentryId[id])
		gimenuSentryId[id] = 0
		return PLUGIN_CONTINUE
	}
	
	if(item == 0)
	{
		gPlayerTurretDamageLevel[id][gimenuSentryId[id]]++
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-gTurretsPriceData[e_TurretsType:pev(gPlayerTurretEnt[id][gimenuSentryId[id]], pev_turret_type)][gPlayerTurretDamageLevel[id][gimenuSentryId[id]]])
	}
	if(item == 1)
	{
		gPlayerTurretRangeLevel[id][gimenuSentryId[id]]++
		td_set_user_info(id, PLAYER_GOLD, td_get_user_info(id, PLAYER_GOLD)-gTurretsPriceData[e_TurretsType:pev(gPlayerTurretEnt[id][gimenuSentryId[id]], pev_turret_type)][gPlayerTurretRangeLevel[id][gimenuSentryId[id]]])
	}
	
	gPlayerTurretLevel[id][gimenuSentryId[id]] = floatround((gPlayerTurretDamageLevel[id][gimenuSentryId[id]]+gPlayerTurretRangeLevel[id][gimenuSentryId[id]] +1)/2.0, floatround_ceil)
	
	new szModel[64];
	formatex(szModel, 63, "models/TD/sentrygun_%d.mdl", gPlayerTurretLevel[id][gimenuSentryId[id]])
	entity_set_model(gPlayerTurretEnt[id][gimenuSentryId[id]], szModel)

	menuUpgradeTurret(id)
	return PLUGIN_CONTINUE
}
public CreateTurretRanger(turret)
{
	if(!is_valid_ent(turret))
		return PLUGIN_CONTINUE
	
	if(td_is_ranger_exists(turret))
		DeleteTurretRanger(turret)
		
	new Float:Origin[3], Float:Angles[3]
	
	new ranger = create_entity("env_sprite")
	
	set_pev(turret, pev_turret_ranger, ranger)
	
	entity_set_string(ranger, EV_SZ_classname, "ranger")
	entity_set_model(ranger, gSpriteRanger)
	set_pev(ranger, pev_turret_owner, pev(turret, pev_turret_owner))
	/*K¹t*/
	entity_get_vector(ranger, EV_VEC_angles, Angles)
	pev(turret, pev_origin, Origin)
	
	Angles[0]+=90
	
	entity_set_origin(ranger, Origin)
	entity_set_vector(ranger, EV_VEC_angles, Angles)
	
	new id = pev(turret, pev_turret_owner)
	new sentryid = pev(turret, pev_turret_id)
	new e_TurretsType:type = e_TurretsType:pev(turret, pev_turret_type)
	new lvl = gPlayerTurretRangeLevel[id][sentryid]
	new range = gTurretsRangeData[type][lvl]
	
	set_pev(ranger, pev_scale, range/250.0)
	fm_set_rendering(ranger, kRenderFxNone, 0, 0, 0, kRenderTransAdd, 255)
	
	return PLUGIN_CONTINUE
}

public DeleteTurretRanger(turret) {
	if(!is_valid_ent(pev(turret, pev_turret_ranger)))
		return PLUGIN_CONTINUE
	
	remove_entity(pev(turret, pev_turret_ranger))
	set_pev(turret, pev_turret_ranger, 0)
	return PLUGIN_CONTINUE
}	
public CreateTurret(id, sentryid, type) {
		
	new Float:fOrigin[3];
	pev(id, pev_origin, fOrigin)
	new entlist[3]
	new num = find_sphere_class(-1, "turret", 50.0, entlist, 2, fOrigin)
	if(num > 0)
	{
		client_print(id, print_center, "Nie mozesz stawiac wiezyczek zbyt blisko siebie!")
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	num = find_sphere_class(-1, "func_illusionary", 10.0, entlist, 2, fOrigin)
	if(num > 0)
	{
		client_print(id, print_center, "W tym miejscu nie mozna postawic wiezyczki!")
		cmdmenuTurrets(id)
		return PLUGIN_CONTINUE
	}
	new iEnt = create_entity("info_target")

	entity_set_string(iEnt, EV_SZ_classname, "turret");
	entity_set_model(iEnt, "models/TD/sentrygun_1.mdl");
	
	entity_set_size(iEnt, Float:{-16.0, -16.0, 0.0}, Float:{16.0, 16.0, 48.0});
	entity_set_origin(iEnt, fOrigin);
	
	entity_set_int(iEnt, EV_INT_movetype, MOVETYPE_TOSS);
	entity_set_vector(iEnt, EV_VEC_angles, Float:{0.0, 0.0, 0.0});
	entity_set_byte(iEnt, EV_BYTE_controller2, 127);
	entity_set_float(iEnt, EV_FL_takedamage, DAMAGE_YES);
	
	set_pev(iEnt, pev_turret_owner, id)
	set_pev(iEnt, pev_turret_id, sentryid)
	set_pev(iEnt, pev_turret_type, type)
	set_pev(iEnt, pev_turret_firemode, 1)
	
	gPlayerTurretType[id][sentryid] = e_TurretsType:type
	gPlayerTurretEnt[id][sentryid] = iEnt
	gPlayerTurretLevel[id][sentryid] = 1
	gPlayerTurretDamageLevel[id][sentryid] = 0
	gPlayerTurretRangeLevel[id][sentryid] = 0
	gPlayerTurretAmmo[id][sentryid] = (e_TurretsType:type==TURRET_NORMAL?100:e_TurretsType:type==TURRET_LASER?51:e_TurretsType:type==TURRET_LIGHTING?200:0)
	gPlayerTurretNum[id]++
	gServerTurretsNum++
	
	emit_sound(id, CHAN_AUTO, gSounds[SOUND_TURRET_PLANT], 1.0, ATTN_NORM, 0, PITCH_NORM);
	
	menuTurret(id, sentryid)
	entity_set_float(iEnt, EV_FL_nextthink, get_gametime()+1.0);
	return PLUGIN_CONTINUE
}
	
public TurretThink(ent) {
	if(!is_valid_ent(ent))
		return PLUGIN_CONTINUE
		
	new e_TurretsType:iType = e_TurretsType:pev(ent, pev_turret_type)
	new iPlayer = pev(ent, pev_turret_owner)
	new iSentry = pev(ent, pev_turret_id)
	new iShoot = pev(ent, pev_turret_firemode)
	new iTarget = pev(ent, pev_turret_target)
	
	static Float:TurretOrigin[3]
	static Float:TargetOrigin[3]
	
	/* Nie strzelaj */
	if(gPlayerTurretAmmo[iPlayer][iSentry] == 0) {
		emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_NOAMMO], 1.0, ATTN_NORM, 0, PITCH_NORM);
		client_cmd(iPlayer, "spk sound/%s", gSounds[SOUND_TURRET_NOAMMO]);
		gPlayerTurretAmmo[iPlayer][iSentry]--
		return PLUGIN_CONTINUE
	}
	/* ============ */
	
	if(iShoot && is_valid_ent(iTarget)) 
	{
		if(!fm_is_ent_visible(ent, iTarget) || pev(iTarget, pev_iuser1) == 0) 
		{
			fireoff:
			iShoot = 0
			set_pev(ent, pev_turret_firemode, 0)
			set_pev(ent, pev_turret_target, 0)
			emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_STOP_FIRE], 1.0, ATTN_NORM, 0, PITCH_NORM);
			
			entity_set_float(ent, EV_FL_nextthink, get_gametime()+0.1);
			return PLUGIN_CONTINUE
		}
		
		pev(iTarget, pev_origin, TargetOrigin)
		pev(ent, pev_origin, TurretOrigin)
		
		if(get_distance_f(TargetOrigin, TurretOrigin) > gTurretsRangeData[iType][gPlayerTurretRangeLevel[iPlayer][iSentry]])
			goto fireoff;
		
			
		TurretTurnToTarget(ent, iTarget);
		
		TurretOrigin[2] += 45.0
		
		gPlayerTurretAmmo[iPlayer][iSentry]--
		
		if(gPlayerTurretAmmo[iPlayer][iSentry] == 50)
		{
			client_cmd(iPlayer, "spk sound/%s", gSounds[SOUND_TURRET_LOWAMMO]);
			emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LOWAMMO], 1.0, ATTN_NORM, 0, PITCH_NORM);
		}
		
		switch(iType) {
			case TURRET_NORMAL: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_NORMAL_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_NORMAL_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
			case TURRET_LASER: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LASER_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LASER_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
			case TURRET_LIGHTING: 
			{
				switch(random_num(1, 2))
				{
					case 1:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LIGHTING_FIRE_1], 1.0, ATTN_NORM, 0, PITCH_NORM);
					case 2:emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_LIGHTING_FIRE_2], 1.0, ATTN_NORM, 0, PITCH_NORM);
				}
			}
		}
		switch(iType) {
			case TURRET_NORMAL: {
				message_begin(MSG_BROADCAST, SVC_TEMPENTITY);
				write_byte(TE_TRACER);
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				message_end();
				
				createShell(ent, TurretOrigin, 1)
			}
			case TURRET_LASER: {
				message_begin(MSG_BROADCAST ,SVC_TEMPENTITY)
				write_byte(TE_BEAMPOINTS)
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				write_short(gSpriteLaserBeam)
				write_byte(0)
				write_byte(0)
				write_byte(1) // time
				write_byte(5*(gPlayerTurretLevel[iPlayer][iSentry])) // gruboœæ
				write_byte(1)
				switch(gPlayerTurretLevel[iPlayer][iSentry]) {
					case 1: {
						write_byte(255)
						write_byte(255)
						write_byte(255)
					} 
					case 2: {
						write_byte(0)
						write_byte(255)
						write_byte(0)
					}
					case 3: {
						write_byte(255)
						write_byte(255)
						write_byte(0)
					} 
					case 4: {
						write_byte(255)
						write_byte(0)
						write_byte(0)
					} 
					case 5:{
						write_byte(0)
						write_byte(0)
						write_byte(255)
					}
				}
				write_byte(255)
				write_byte(5)
				message_end()
			}
			case TURRET_LIGHTING: {
				message_begin(MSG_BROADCAST ,SVC_TEMPENTITY)
				write_byte(TE_BEAMPOINTS)
				write_coord(floatround(TurretOrigin[0]));
				write_coord(floatround(TurretOrigin[1]));
				write_coord(floatround(TurretOrigin[2]));
				write_coord(floatround(TargetOrigin[0]));
				write_coord(floatround(TargetOrigin[1]));
				write_coord(random_num(floatround(TargetOrigin[2])-20, floatround(TargetOrigin[2])+30));
				write_short(gSpriteLaserBeam)
				write_byte(0)
				write_byte(0)
				write_byte(1) // time
				write_byte(10) // gruboœæ
				write_byte(16)
				switch(gPlayerTurretLevel[iPlayer][iSentry]) {
					case 1: {
						write_byte(255)
						write_byte(255)
						write_byte(255)
					} 
					case 2: {
						write_byte(0)
						write_byte(255)
						write_byte(0)
					}
					case 3: {
						write_byte(255)
						write_byte(255)
						write_byte(0)
					} 
					case 4: {
						write_byte(255)
						write_byte(0)
						write_byte(0)
					} 
					case 5:{
						write_byte(0)
						write_byte(0)
						write_byte(255)
					}
				}
				write_byte(255)
				write_byte(5) //szybkoœæ
				message_end()
			}	
		}
		
		/*Zadawanie obrazen*/
		switch(random_num(1, 4)) {
			case 1, 2, 3: {
				new Float:dmg
				dmg = random_float(float(gTurretsDamageData[iType][gPlayerTurretDamageLevel[iPlayer][iSentry]][0]),float(gTurretsDamageData[iType][gPlayerTurretDamageLevel[iPlayer][iSentry]][1]))
				ExecuteHamB(Ham_TakeDamage, iTarget, iPlayer, iPlayer, dmg, DMG_DROWN, 1);
			}
			case 4: {
				// jeœli wie¿yczka nietrafi³a
			}
		}
		/* thinki */
		
		switch(iType) {
			case TURRET_NORMAL: entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (gTurretsFreqData[TURRET_NORMAL]/100.0));
			case TURRET_LASER: entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (gTurretsFreqData[TURRET_LASER]/100.0));
			case TURRET_LIGHTING: entity_set_float(ent, EV_FL_nextthink, get_gametime()+ (gTurretsFreqData[TURRET_LIGHTING]/100.0));
		}
		
		return PLUGIN_CONTINUE	
	}
	else
		iShoot = 0
		
	iTarget = TurretGetClosestMonster(ent)

	if(iTarget && (iTarget && fm_is_ent_visible(ent, iTarget)))
	{
		emit_sound(ent, CHAN_AUTO, gSounds[SOUND_TURRET_START_FIRE], 1.0, ATTN_NORM, 0, PITCH_NORM);
		TurretTurnToTarget(ent, iTarget);
		
		set_pev(ent, pev_turret_target, iTarget)
		set_pev(ent, pev_turret_firemode, 1)
		
		entity_set_float(ent, EV_FL_nextthink, get_gametime()+0.5);
		return PLUGIN_CONTINUE
	}
	

	
	/*  Stan Wolny  */
	if(!iShoot) {
		
		new controler1 = entity_get_byte(ent, EV_BYTE_controller1)+2;
		if(controler1 > 255)
			controler1 = 0;
		entity_set_byte(ent, EV_BYTE_controller1, controler1);
			
		new controler2 = entity_get_byte(ent, EV_BYTE_controller2);
		if(controler2 > 127 || controler2 < 127)
			entity_set_byte(ent, EV_BYTE_controller2, 127);
		

		entity_set_float(ent, EV_FL_nextthink, get_gametime()+0.25);
	}
	return PLUGIN_CONTINUE
}
stock get_origin_from_dist_player(id, Float:dist, Float:origin[3], s3d = 1) {
	new Float:idorigin[3];
	entity_get_vector(id, EV_VEC_origin, idorigin); // lub pev(id, pev_origin, idorigin) dla fakemety
	
	if(dist == 0) {
		origin = idorigin;
		return;
	}
	
	new Float:idvangle[3];
	entity_get_vector(id, EV_VEC_v_angle, idvangle); // lub pev(id, pev_v_angle, idvangle) dla fakemety
	
	idvangle[0] *= -1;
	
	origin[0] = idorigin[0] + dist * floatcos(idvangle[1], degrees) * ((s3d) ? floatabs(floatcos(idvangle[0], degrees)) : 1.0);
	origin[1] = idorigin[1] + dist * floatsin(idvangle[1], degrees) * ((s3d) ? floatabs(floatcos(idvangle[0], degrees)) : 1.0);
	origin[2] = idorigin[2] + ((s3d) ? dist * floatsin(idvangle[0], degrees) : 0.0);
}
stock TurretTurnToTarget(ent, enemy, mode = 0, Float:enemyOrigin[3] = {0.0, 0.0, 0.0})
{
	static Float:sentryOrigin[3], Float:closestOrigin[3]
	pev(ent, pev_origin, sentryOrigin)
	
	if(enemyOrigin[0] == 0.0 && enemyOrigin[1] == 0.0 && enemyOrigin[2] == 0.0)
		pev(enemy, pev_origin, closestOrigin)
	else
		closestOrigin = enemyOrigin
		
	new newTrip, Float:newAngle = floatatan(((closestOrigin[1]-sentryOrigin[1])/(closestOrigin[0]-sentryOrigin[0])), radian) * 57.2957795;

	if(closestOrigin[0] < sentryOrigin[0])
		newAngle += 180.0;
	if(newAngle < 0.0)
		newAngle += 360.0;
	
	sentryOrigin[2] += 35.0
	if(closestOrigin[2] > sentryOrigin[2])
		newTrip = 0;
	if(closestOrigin[2] < sentryOrigin[2])
		newTrip = 255;
	if(closestOrigin[2] == sentryOrigin[2])
		newTrip = 127;
		
	entity_set_byte(ent, EV_BYTE_controller1, floatround(newAngle*0.70833));
	entity_set_byte(ent, EV_BYTE_controller2, newTrip);
	
	if(!mode)
	{
		entity_set_byte(ent, EV_BYTE_controller3, entity_get_byte(ent, EV_BYTE_controller3)+20>255? 0: entity_get_byte(ent, EV_BYTE_controller3)+20);
	}
}

public TurretGetClosestMonster(ent) {
	new Float:flDistanse = float( gTurretsRangeData[e_TurretsType:pev(ent, pev_turret_type)][gPlayerTurretRangeLevel[pev(ent, pev_turret_owner)][pev(ent, pev_turret_id)]])
	new Float:fOrigin1[3];
	new Float:fOrigin2[3]
	
	pev(ent, pev_origin, fOrigin1)
	
	new tempEntID;
	new entlist[6]
	new Float:dis;
	for(new i ; i < find_sphere_class(ent, "monster", flDistanse, entlist, 5) ; i++) 
	{	if(pev(entlist[i], pev_iuser1) == 0)
			continue

		pev(entlist[i], pev_origin, fOrigin2);
		
		dis = get_distance_f(fOrigin1, fOrigin2)
		if(dis < flDistanse)
		{
			flDistanse = dis;
			tempEntID = entlist[i];
		}	
	}
	return tempEntID;
}

public LoadSound() {
	new szText[128], len;
	new szTemp[3][128];

	if(!file_exists(gszSoundConfigFile))
	{
		log_to_file(gszLogFile, "Brak pliku konfiguracyjnego dzwiekow...")
		return PLUGIN_CONTINUE
	}
	
	for(new i ; read_file(gszSoundConfigFile, i, szText, 127, len) ; i++)
	{
		if(equali(szText, ";") || equali(szText, ""))
			continue;
			
		parse(szText, szTemp[0], 127, szTemp[1], 16, szTemp[2], 127)
		remove_quotes(szTemp[2]);
		
		if(equali(szTemp[0], "TURRET_NORMAL_FIRE_1")) 
			copy(gSounds[SOUND_TURRET_NORMAL_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_NORMAL_FIRE_2")) 
			copy(gSounds[SOUND_TURRET_NORMAL_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LASER_FIRE_1")) 
			copy(gSounds[SOUND_TURRET_LASER_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LASER_FIRE_2")) 
			copy(gSounds[SOUND_TURRET_LASER_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LIGHTING_FIRE_1")) 
			copy(gSounds[SOUND_TURRET_LIGHTING_FIRE_1], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LIGHTING_FIRE_2")) 
			copy(gSounds[SOUND_TURRET_LIGHTING_FIRE_2], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_START_FIRE")) 
			copy(gSounds[SOUND_TURRET_START_FIRE], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_STOP_FIRE")) 
			copy(gSounds[SOUND_TURRET_STOP_FIRE], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_PLANT")) 
			copy(gSounds[SOUND_TURRET_PLANT], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_LOW_AMMO")) 
			copy(gSounds[SOUND_TURRET_LOWAMMO], 127, szTemp[2])
		else if(equali(szTemp[0], "TURRET_NO_AMMO")) 
			copy(gSounds[SOUND_TURRET_NOAMMO], 127, szTemp[2])
		else if(equali(szTemp[0], "MENU_SELECT")) 
			copy(gSounds[SOUND_MENU_SELECT], 127, szTemp[2])
	}

	return PLUGIN_CONTINUE
}

public LoadTurretsConfig()
{
	new szText[64], len
	new szData[64], iData[2][6]
	new szFormat[64]
	
	server_cmd("exec addons/amxmodx/configs/td_cvars.cfg");
	
	if(!file_exists(gszTurretsConfigFile))
	{
		log_to_file("Tower Defense.log", "TURRETS : Brak pliku konfiguracyjnego '%s'. Gra niemozliwa. ", gszTurretsConfigFile)
		td_set_game_status(eGame:GAME_NOT_AVAILABLE)
		return PLUGIN_CONTINUE
	}
	
	for(new i = 0 ; read_file(gszTurretsConfigFile, i, szText, 63, len); i ++)
	{
		if(szText[0] == ';' || (szText[0] == '/' && szText[1] == '/') || equali(szText, ""))
			continue;
		
		replace_all(szText, 63, "=", "")
		
		parse(szText, szData, 63, iData[0], 5, iData[1], 5)
		
		new iNum = str_to_num(iData[0])
		new iNum2 = str_to_num(iData[1])
		
		if(equali(szData, "NORMAL_TURRET_FIRE_FREQ"))
		{
			gTurretsFreqData[TURRET_NORMAL] = iNum
			continue
		}
		
		for(new x = 1 ; x <= 5; x++)
		{
			formatex(szFormat, 63, "NORMAL_TURRET_RANGE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsRangeData[TURRET_NORMAL][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "NORMAL_TURRET_PRICE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsPriceData[TURRET_NORMAL][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "NORMAL_TURRET_DMG_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsDamageData[TURRET_NORMAL][x-1][0] = iNum
				gTurretsDamageData[TURRET_NORMAL][x-1][1] = iNum2
				iNum2 =0
				continue
			}
		}
		
		if(equali(szData, "LASER_TURRET_FIRE_FREQ"))
		{
			gTurretsFreqData[TURRET_LASER] = iNum
			continue
		}
		
		for(new x = 1; x <= 5; x++)
		{
			formatex(szFormat, 63, "LASER_TURRET_RANGE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsRangeData[TURRET_LASER][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "LASER_TURRET_PRICE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsPriceData[TURRET_LASER][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "LASER_TURRET_DMG_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsDamageData[TURRET_LASER][x-1][0] = iNum
				gTurretsDamageData[TURRET_LASER][x-1][1] = iNum2
				iNum2 =0
				continue
			}
		}
		
		if(equali(szData, "LIGHTING_TURRET_FIRE_FREQ"))
		{
			gTurretsFreqData[TURRET_LIGHTING] = iNum
			continue
		}
		
		for(new x = 1; x <= 5; x++)
		{
			formatex(szFormat, 63, "LIGHTING_TURRET_RANGE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsRangeData[TURRET_LIGHTING][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "LIGHTING_TURRET_PRICE_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsPriceData[TURRET_LIGHTING][x-1] = iNum
				continue
			}
			formatex(szFormat, 63, "LIGHTING_TURRET_DMG_%d", x)
			if(equali(szData, szFormat))
			{
				gTurretsDamageData[TURRET_LIGHTING][x-1][0] = iNum
				gTurretsDamageData[TURRET_LIGHTING][x-1][1] = iNum2
				iNum2 =0
				continue
			}
		}
		
		
	}
	MAX_MAP_TURRET = clamp(max_map_turrets(), 1, MAX_SERVER_TURRET)
	return PLUGIN_CONTINUE;
}

stock createShell(index, Float:fOrigin[3], num)
{
	for(new i; i < num;i++)
	{
		message_begin(MSG_BROADCAST, SVC_TEMPENTITY, {0.0, 0.0, 0.0}, index);
		write_byte(TE_MODEL);
		write_coord(floatround(fOrigin[0]));
		write_coord(floatround(fOrigin[1]));
		write_coord(floatround(fOrigin[2]));
		write_coord(random_num(-100,100));
		write_coord(random_num(-100,100));
		write_coord(random_num(100,200));
		write_angle(random_num(0,360));
		write_short(gShellIndex);
		write_byte(0);
		write_byte(100);
		message_end()
	}
}

public td_is_turret(iEnt)
{
	if(!is_valid_ent(iEnt))
		return 0;
	
	new classname[8]
	entity_get_string(iEnt, EV_SZ_classname, classname, 7)
	if(equali(classname, "turret"))
		return 1;
	return 0;
}

public td_is_ranger(iEnt)
{
	if(!is_valid_ent(iEnt))
		return 0;
	
	new classname[8]
	entity_get_string(iEnt, EV_SZ_classname, classname, 7)
	if(equali(classname, "ranger"))
		return 1;
	return 0;
}

public td_is_ranger_exists(iEnt) {	
	if(is_valid_ent(pev(iEnt, pev_turret_ranger)))
		return 1;
	return 0;
}
	
