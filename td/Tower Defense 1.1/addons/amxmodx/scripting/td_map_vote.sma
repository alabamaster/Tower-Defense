/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <td>
#include <colorchat>

#define PLUGIN "TD: Vote Map"
#define VERSION "1.0"
#define AUTHOR "tomcionek15 & grs4"

#define MAPCYCLE_MAX_MAPS 33

new const g_szMapCycleFile[] = "mapcycle-towerdefense.txt";
new const g_szChatPrefix[]	= "[TD: Map Chooser]";
new const g_szLastMapFile[] = "mapcycle-lastmap.txt";
new bool:g_PluginOn;
new bool:g_PlayerVoted[33];
new bool:g_TimeToVote;

new g_szLastMapName[33]
new g_szMaps[MAPCYCLE_MAX_MAPS][33];
new g_iMapsVote[MAPCYCLE_MAX_MAPS]
new g_iMapsNum;
new g_iMaxPlayers;
new g_iMaxMapWave;

new g_CvarTimeToVote;
new g_CvarWithRefresh;
new g_CvarHowManyWaves;
new g_CvarVoteMode;


public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR);
	
	register_clcmd("say /mapreset", "cmdAdminResetMap", ADMIN_KICK)
	
	g_CvarTimeToVote 	= create_cvar("td_vote_time", "15", _, _, true, 1.0, false, _)
	g_CvarWithRefresh 	= create_cvar("td_vote_refresh_menu", "1", _, _, true, 0.0, true, 1.0)
	g_CvarHowManyWaves	= create_cvar("td_vote_waves", "3", _, _, true, 1.0, false, _)
	g_CvarVoteMode 		= create_cvar("td_vote_mode", "1", _, _, true, 0.0, true, 3.0)

	// VoteModes:
	// 1 - After First Wave 
	// 2 - X wave before end wave [in cvar td_vote_waves]
	// 3 - Random map (not actually)
	
	g_iMaxPlayers = get_maxplayers();
	g_iMaxMapWave = td_get_wavenum();
	
	LoadLastMap()
}

/////////
public cmdAdminResetMap(id) {
	delete_file(g_szLastMapFile)
	client_print(id, 3, "Last map %s has just deleted!", g_szLastMapName)
}

public LoadLastMap() {
	new len
	read_file(g_szLastMapFile, 0, g_szLastMapName, charsmax(g_szLastMapName), len)
	delete_file(g_szLastMapFile)
}

public plugin_end() {
	new szMapName[33]
	get_mapname(szMapName, charsmax(szMapName))
	write_file(g_szLastMapFile, szMapName, 0)
}
/////////

public plugin_cfg() {
	if(file_exists(g_szMapCycleFile))
		set_cvar_string("mapcyclefile", g_szMapCycleFile);
	else
		log_amx("TD: VoteMap | Mapcycle file '%s' does not exist!", g_szMapCycleFile);

	new szMapCycleFile[33];
	get_cvar_string("mapcyclefile", szMapCycleFile, 32);
		
	if(!file_exists(szMapCycleFile)) {
		g_PluginOn = false;
		return;
	}
	
	new szText[33], iLen;
	
	for(new i; read_file(szMapCycleFile, i, szText, 149, iLen) ; i++) {
		trim(szText);
		remove_quotes(szText);
		if(equali(szText, "") || equali(szText, " "))
			continue
		formatex(g_szMaps[i], 32, szText);
		g_iMapsNum ++;
	}
	
	/* Brak zapisanych map */
	if(!g_iMapsNum) {
		log_amx("TD: VoteMap | Mapcycle file '%s' is empty!", szMapCycleFile);
		g_PluginOn = false;
		return;
	}

	g_PluginOn = true;
}

public cmdVoteMap() {
	if(!g_PluginOn)
		return;
	
	if(get_pcvar_num(g_CvarVoteMode) == 3) {
		cmdSetRandomMap();
		return;
	}

	g_TimeToVote = true;
	
	ColorChat(0, GREEN, "^x04%s^x01 Voting is started! Time remaing %d second!", g_szChatPrefix, get_pcvar_num(g_CvarTimeToVote));
	set_task(float(get_pcvar_num(g_CvarTimeToVote)), "cmdVoteMapEnd");

	for(new i = 1; i <= g_iMaxPlayers ; i++)
		if(is_user_connected(i))
			showMenu(i,0)
}

public showMenu(id,page) {
	new szTitle[64];
	new szItem[64];

	formatex(szTitle, charsmax(szTitle), "\yChoose next map: ");
	
	new iMenu  = menu_create(szTitle, "cmdVoteMap_Handler");
	new iCb = menu_makecallback("cmdVoteMap_Callback");

	for(new i ; i < g_iMapsNum ; i++) {
		get_mapname(szItem, 63)
		if(equali(g_szLastMapName, g_szMaps[i]), equali(szItem, g_szMaps[i]))
			continue;
		
		formatex(szItem, charsmax(szItem), "\w%s \y[ \w%d votes \y]", g_szMaps[i], g_iMapsVote[i])
		
		new iIndex[4];
		num_to_str(i, iIndex, 3);
		
		menu_additem(iMenu, szItem, iIndex, _, iCb);
	}
	
	menu_display(id, iMenu, page, get_pcvar_num(g_CvarTimeToVote))
}
public cmdVoteMap_Callback(id, menu, item) {
	if(g_PlayerVoted[id])
		return ITEM_DISABLED;

	return ITEM_ENABLED;
}

public cmdVoteMap_Handler(id, menu, item) {
	if(!is_user_connected(id) || !g_TimeToVote)
		return;
	
	if(item == MENU_EXIT && !g_PlayerVoted[id]) {
		menu_display(id, menu);
		return;
	}
	if(!g_PlayerVoted[id]) {
		new szData[6], iName[4];
		new access, callback;
		new szNick[33];
		get_user_name(id, szNick, 32);
	
		menu_item_getinfo(menu, item, access, szData, 5, iName, 3, callback);
		new iIndex = str_to_num(szData);
	
		g_PlayerVoted[id] = true;
		g_iMapsVote[iIndex] ++;
	
		ColorChat(0, GREEN, "^x04%s^x01 Player^x04 %s^x01 voted for^x04 %s.", g_szChatPrefix, szNick, g_szMaps[iIndex])
	} else return
	static bool:iRefresh;
	if(!iRefresh) 
		iRefresh = bool:get_pcvar_num(g_CvarWithRefresh)
	
	if(iRefresh)
		cmdRefreshMenu(id, menu);
	showMenu(id, 0)
}

public cmdRefreshMenu(id, iMenu) {
	if(!g_TimeToVote)
		return
	for(new i = 1; i <= g_iMaxPlayers ; i++) {
		if(is_user_connected(i) && i != id) {
			showMenu(i, 0)
		}
	}
}

public td_endwave(iWave) {
	new iCvarValue = get_pcvar_num(g_CvarVoteMode);
	
	if(iCvarValue == 1) {
		if(iWave == 1) {
			cmdVoteMap();
		}
	} else if(iCvarValue == 2) {
		if((g_iMaxMapWave - get_pcvar_num(g_CvarHowManyWaves)) == iWave) {
			cmdVoteMap();
		}
	}
}

public cmdVoteMapEnd() {
	ColorChat(0, GREEN, "^x04%s^x01 Voting for next map has just end!", g_szChatPrefix)
	g_TimeToVote = false
	new iTemp = 0, id=0
	new ids[9]
	
	for(new i ; i < MAPCYCLE_MAX_MAPS ; i++) {
		if(g_iMapsVote[i] > iTemp) {
			id = i
			iTemp = g_iMapsVote[id]
		}
	}
	ids[0] = id
	
	new iTemp2  = 1
	
	for(new i ; i < MAPCYCLE_MAX_MAPS ; i++) {
		if(g_iMapsVote[i] == iTemp && i != id && iTemp && iTemp2 < sizeof ids) {
			ids[iTemp2++] = i
		}
	}
	
	// If map has 0 votes
	if(iTemp == 0) {
		new rand = random(g_iMapsNum-1)
		ColorChat(0, GREEN, "^x04%s^x01 No one had voted, the next map will be random choosed:^x04 %s!", g_szChatPrefix, g_szMaps[rand])
		set_cvar_string("amx_nextmap", g_szMaps[rand ])
		return
	}

	// If are two maps which have this same num of votes
	if(iTemp2 > 1) {
		new rand = random(iTemp2)
		iTemp = ids[rand]

		ColorChat(0, GREEN, "^x04%s^x01 Between^x04 %d^x01 maps [^x04 %d votes ^x01] will be drawn one map!", g_szChatPrefix, iTemp2, g_iMapsVote[iTemp])
		set_task(3.0, "printEndChat", iTemp)
		return
		
	}

	iTemp = id

	printEndChat(iTemp)
	cmdResetVoteInfo();
}

public cmdResetVoteInfo() {
	for(new i ; i < MAPCYCLE_MAX_MAPS ; i++)
		g_iMapsVote[i] = 0
	
	for(new i = 1; i <= g_iMaxPlayers ; i++)
		g_PlayerVoted[i] = false
}

public printEndChat(iTemp) {
	ColorChat(0, GREEN, "^x04%s^x01 Next map will be ^x04%s^x01 with^x04 %d^x01 votes!", g_szChatPrefix, g_szMaps[iTemp], g_iMapsVote[iTemp])
	set_cvar_string("amx_nextmap", g_szMaps[iTemp]);
}

public cmdSetRandomMap() {
	new iRandomIndex = random(g_iMapsNum);
	set_cvar_string("amx_nextmap", g_szMaps[iRandomIndex])

	ColorChat(0, GREEN, "^x04%s^x01 Next map will be ^x04%s", g_szChatPrefix, g_szMaps[iRandomIndex])
}

